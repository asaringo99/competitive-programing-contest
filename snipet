{
	"yes": {
		"body": [
			"cout << \"Yes\" << endl ;",
		],
		"description": "yes",
		"prefix": "yes"
	},

	"no": {
		"body": [
			"cout << \"No\" << endl ;",
		],
		"description": "no",
		"prefix": "no"
	},
	
	"graph_n": {
		"body": [
			"rep(i,n-1){",
			"    int u , v ;",
			"    cin >> u >> v ;",
			"    u-- ; v-- ;",
			"    G[u].push_back(v) ;",
			"    G[v].push_back(u) ;",
			"}",
		],
		"description": "graph_n",
		"prefix": "graph_n"
	},

	"graph_m": {
		"body": [
			"rep(i,m){",
			"    int u , v ;",
			"    cin >> u >> v ;",
			"    u-- ; v-- ;",
			"    G[u].push_back(v) ;",
			"    G[v].push_back(u) ;",
			"}",
		],
		"description": "graph_m",
		"prefix": "graph_m"
	},
	
	"mod_1000000007": {
		"body": [
			"const int mod = 1000000007 ;",
		],
		"description": "mod",
		"prefix": "mod"
	},
	
	"mod_998244353": {
		"body": [
			"const int mod = 998244353 ;",
		],
		"description": "mod",
		"prefix": "mod"
	},

	"powmod": {
		"body": [
			"ll powmod(ll x , ll n){",
			"    ll res = 1 ;",
			"    while(n > 0){",
			"        if(n & 1) (res *= x) %= mod ;",
			"        (x *= x) %= mod ;",
			"        n >>= 1 ;",
			"    }",
			"    return res ;",
			"}",
		],
		"description": "powmod",
		"prefix": "powmod"
	},

	"powll": {
		"body": [
			"ll powll(ll x , ll n){",
			"    ll res = 1 ;",
			"    while(n > 0){",
			"        if(n & 1) res *= x ;",
			"        x *= x ;",
			"        n >>= 1 ;",
			"    }",
			"    return res ;",
			"}",
		],
		"description": "powll",
		"prefix": "powll"
	},
	
	"combination": {
		"body": [
			"const int mod = 1000000007 ;",
			"const int MAX_N = 505050 ;",
			"",
			"ll inv[MAX_N+1] ; // (n!)^(p-2) (mod p) を格納",
			"ll fac[MAX_N+1] ; // (n!) (mod p) を格納",
			"",
			"ll powmod(ll x , ll n){",
			"    ll res = 1 ;",
			"    while(n > 0){",
			"        if(n & 1) (res *= x) %= mod ;",
			"        (x *= x) %= mod ;",
			"        n >>= 1 ;",
			"    }",
			"    return res ;",
			"}",
			"",
			"// 階乗の逆元(n!)^(-1)のmodを配列に格納",
			"void f(){",
			"    inv[0] = 1 ; inv[1] = 1 ;",
			"    for(ll i = 2 ; i <= MAX_N ; i++){",
			"        inv[i] = powmod(i,mod-2) * inv[i-1] % mod ;",
			"    }",
			"}",
			"",
			"// 階乗のmodを配列に格納",
			"void g(){",
			"    fac[0] = 1 ; fac[1] = 1 ;",
			"    for(ll i = 2 ; i <= MAX_N ; i++){",
			"        fac[i] = (fac[i-1] * i) % mod ;",
			"    }",
			"}",
			"",
			"//nCrの計算",
			"ll combination(ll n , ll r){",
			"    if(n < 0 || r < 0 || n < r) return 0 ;",
			"    return fac[n] * inv[n-r] % mod * inv[r] % mod ;",
			"}",
			"",
			"ll permutation(ll n , ll r){",
			"    if(n < 0 || r < 0 || n < r) return 0 ;",
			"    return fac[n] * inv[n-r] % mod ;",
			"}",
			"",
			"void init(){ f() ; g() ; }",
		],
		"description": "combination",
		"prefix": "combination"
	},

    "combination_mod": {
        "prefix": "combination",
        "body": [
            "const int mod = 998244353 ;",
            "",
            "template< int mod >",
            "struct ModInt {",
            "    int x;",
            "",
            "    ModInt() : x(0) {}",
            "",
            "    ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}",
            "",
            "    ModInt &operator+=(const ModInt &p) {",
            "        if((x += p.x) >= mod) x -= mod;",
            "        return *this;",
            "    }",
            "",
            "    ModInt &operator-=(const ModInt &p) {",
            "        if((x += mod - p.x) >= mod) x -= mod;",
            "        return *this;",
            "    }",
            "",
            "    ModInt &operator*=(const ModInt &p) {",
            "        x = (int) (1LL * x * p.x % mod);",
            "        return *this;",
            "    }",
            "",
            "    ModInt &operator/=(const ModInt &p) {",
            "        *this *= p.inverse();",
            "        return *this;",
            "    }",
            "",
            "    ModInt operator-() const { return ModInt(-x); }",
            "",
            "    ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }",
            "",
            "    ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }",
            "",
            "    ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }",
            "",
            "    ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }",
            "",
            "    bool operator==(const ModInt &p) const { return x == p.x; }",
            "",
            "    bool operator!=(const ModInt &p) const { return x != p.x; }",
            "",
            "    ModInt inverse() const {",
            "        int a = x, b = mod, u = 1, v = 0, t;",
            "        while(b > 0) {",
            "            t = a / b;",
            "            swap(a -= t * b, b);",
            "            swap(u -= t * v, v);",
            "        }",
            "        return ModInt(u);",
            "    }",
            "",
            "    ModInt pow(int64_t n) const {",
            "        ModInt ret(1), mul(x);",
            "        while(n > 0) {",
            "            if(n & 1) ret *= mul;",
            "            mul *= mul;",
            "            n >>= 1;",
            "        }",
            "        return ret;",
            "    }",
            "",
            "    friend ostream &operator<<(ostream &os, const ModInt &p) {",
            "        return os << p.x;",
            "    }",
            "",
            "    friend istream &operator>>(istream &is, ModInt &a) {",
            "        int64_t t;",
            "        is >> t;",
            "        a = ModInt< mod >(t);",
            "        return (is);",
            "    }",
            "",
            "    static int get_mod() { return mod; }",
            "};",
            "",
            "using modint = ModInt< mod >;",
            "",
            "const int MAX_N = 2010101 ;",
            "",
            "modint inv[MAX_N+1] ; // (n!)^(p-2) (mod p) を格納",
            "modint fac[MAX_N+1] ; // (n!) (mod p) を格納",
            "",
            "modint powmod(modint x , ll n){",
            "    modint res = 1 ;",
            "    while(n > 0){",
            "        if(n & 1) res *= x;",
            "        x *= x;",
            "        n >>= 1 ;",
            "    }",
            "    return res ;",
            "}",
            "",
            "// 階乗の逆元(n!)^(-1)のmodを配列に格納",
            "void f(){",
            "    inv[0] = 1 ; inv[1] = 1 ;",
            "    for(ll i = 2 ; i <= MAX_N ; i++){",
            "        inv[i] = powmod(i,mod-2) * inv[i-1];",
            "    }",
            "}",
            "",
            "// 階乗のmodを配列に格納",
            "void g(){",
            "    fac[0] = 1 ; fac[1] = 1 ;",
            "    for(ll i = 2 ; i <= MAX_N ; i++){",
            "        fac[i] = fac[i-1] * i;",
            "    }",
            "}",
            "",
            "//nCrの計算",
            "modint combination(ll n , ll r){",
            "    if(n < 0 || r < 0 || n < r) return 0 ;",
            "    return fac[n] * inv[n-r] * inv[r];",
            "}",
            "",
            "modint permutation(ll n , ll r){",
            "    if(n < 0 || r < 0 || n < r) return 0 ;",
            "    return fac[n] * inv[n-r];",
            "}",
            "",
            "void init(){ f() ; g() ; }",
        ],
        "description": ""
    },

    "unionfind_potential": {
        "prefix": "unionfind",
        "body": [
            "template<typename T=ll> struct UnionFind {",
            "    private:",
            "        vector<int> parent ; //親",
            "        vector<int> rank ; //木の深さ",
            "        vector<int> volume ; //構成する集合のサイズ",
            "        vector<int> edge ; //構成する集合の辺の数",
            "        vector<T> weight ; //親の重みとの差(親の重みは0)",
            "        vector<bool> paradox;",
            "",
            "    public:",
            "        UnionFind(int n){",
            "            //n要素で初期化",
            "            parent.resize(n) ;",
            "            rank.resize(n,0) ;",
            "            volume.resize(n,1) ;",
            "            edge.resize(n,0) ;",
            "            weight.resize(n,0) ;",
            "            paradox.resize(n,false);",
            "            for(int i = 0 ; i < n ; i++) parent[i] = i ;",
            "        }",
            "",
            "        T potential(int x){",
            "            root(x);",
            "            return weight[x];",
            "        }",
            "",
            "        //木の根を求める",
            "        int root(int x) {",
            "            if(parent[x] == x) return x;",
            "            int r = root(parent[x]);",
            "            weight[x] += weight[parent[x]];",
            "            return parent[x] = r;",
            "        }",
            "",
            "        //xとyの属する集合を合併",
            "        void unite(int x, int y, T w = 0){",
            "            w += potential(x) - potential(y);",
            "",
            "            x = root(x);",
            "            y = root(y);",
            "            if(x == y) {",
            "                if(w != 0) paradox[x] = true;",
            "                edge[x]++ ;",
            "                return ;",
            "            }",
            "            if(rank[x] < rank[y]){",
            "                swap(x,y);",
            "                w = -w;",
            "            } ",
            "            if(rank[x] == rank[y]) rank[x]++;",
            "            if(paradox[y]) paradox[x] = true;",
            "            parent[y] = x;",
            "            volume[x] += volume[y];",
            "            edge[x] += edge[y] + 1;",
            "            weight[y] = w;",
            "        }",
            "",
            "        bool same(int x , int y) { return root(x) == root(y); }",
            "        int size(int x) { return volume[root(x)]; }",
            "        int edge_num(int x) { return edge[root(x)]; }",
            "        T diff(int x, int y){ return potential(y) - potential(x); }",
            "        bool conflict(int x) { return paradox[root(x)]; }",
            "};",
        ],
        "description": ""
    },

    "unionfind": {
        "prefix": "unionfind",
        "body": [
            "struct UnionFind {",
            "    private:",
            "        vector<int> par ; //親",
            "        vector<int> lank ; //木の深さ",
            "        vector<int> volume ; //構成する集合のサイズ",
            "        vector<int> edge ; //構成する集合の辺の数",
            "",
            "    public:",
            "        UnionFind(int n){",
            "            //n要素で初期化",
            "            par.resize(n) ;",
            "            lank.resize(n) ;",
            "            volume.resize(n) ;",
            "            edge.resize(n) ;",
            "            for(int i = 0 ; i < n ; i++){",
            "                par[i] = i ;",
            "                lank[i] = 0 ;",
            "                volume[i] = 1 ;",
            "                edge[i] = 0 ;",
            "            }",
            "        }",
            "        //木の根を求める",
            "        int root(int x) {",
            "            if(par[x] == x) return x ;",
            "            else return par[x] = root(par[x]) ;",
            "        }",
            "",
            "        //xとyの属する集合を合併",
            "        void unite(int x , int y){",
            "            x = root(x);",
            "            y = root(y) ;",
            "            if(x == y) {",
            "                edge[x]++ ;",
            "                return ;",
            "            }",
            "            if(lank[x] < lank[y]){",
            "                par[x] = y ;",
            "                volume[y] += volume[x] ;",
            "                edge[y] += edge[x] + 1 ;",
            "            } else {",
            "                par[y] = x ;",
            "                volume[x] += volume[y] ;",
            "                edge[x] += edge[y] + 1 ;",
            "                if(lank[x] == lank[y]) lank[x]++ ;",
            "            }",
            "        }",
            "",
            "        bool same(int x , int y) { return root(x) == root(y) ; }",
            "        int size(int x) { return volume[root(x)] ; }",
            "        int edge_num(int x) { return edge[root(x)] ; }",
            "};",
        ],
        "description": ""
    },
	
    "hash_map": {
        "prefix": "hash_map",
        "body": [
            "template<typename Key,typename Val>",
            "struct hash_map{",
            "    using u32=uint32_t;",
            "    using u64=uint64_t;",
            "    using Data=pair<Key,Val>;",
            "    protected:",
            "        template <typename K>",
            "        inline u64 randomized(const K&key)const{",
            "            return u64(key)^r;",
            "        }",
            "    template<typename K,enable_if_t<is_integral<K>::value,nullptr_t> = nullptr>",
            "    inline u64 inner_hash(const K&key)const{",
            "        return (randomized(key)*11995408973635179863ULL);",
            "    }",
            "    template<typename K,enable_if_t<is_integral<decltype(K::first)>::value,nullptr_t> = nullptr,enable_if_t<is_integral<decltype(K::second)>::value,nullptr_t> = nullptr>",
            "        inline u64 inner_hash(const K&key)const{",
            "            u64 a=randomized(key.first),b=randomized(key.second);",
            "            a*=11995408973635179863ULL;",
            "            b*=10150724397891781847ULL;",
            "            return (a+b);",
            "    }",
            "    template <typename K,enable_if_t<is_integral<typename K::value_type>::value,nullptr_t> = nullptr>",
            "    inline u64 inner_hash(const K&key)const{",
            "        static constexpr u64 mod=(1LL << 61)-1;",
            "        static constexpr u64 base=950699498548472943ULL;",
            "        u64 res=0;",
            "        for(auto&elem:key) {",
            "            __uint128_t x=__uint128_t(res)*base+(randomized(elem)&mod);",
            "            res=(x&mod)+(x>>61);",
            "        }",
            "        __uint128_t x=__uint128_t(res)*base;",
            "        res=(x&mod)+(x >> 61);",
            "        if(res>=mod)res-=mod;",
            "        return (res<<3);",
            "    }",
            "    inline u32 hash(const Key&key)const{",
            "        return inner_hash(key)>>shift;",
            "    }",
            "    void reallocate(u32 new_cap){",
            "        vector<Data>new_data(new_cap);",
            "        vector<bool>new_flag(new_cap,false);",
            "        shift=64-__lg(new_cap);",
            "        for(u32 i=0;i<cap;i++){",
            "            if(flag[i]&&!dflag[i]){",
            "                u32 h=hash(data[i].first);",
            "                while(new_flag[h])h=(h+1)&(new_cap-1);",
            "                new_data[h]=move(data[i]);",
            "                new_flag[h]=true;",
            "            }",
            "        }",
            "        data.swap(new_data);",
            "        flag.swap(new_flag);",
            "        cap=new_cap;",
            "        dflag.resize(cap);",
            "        fill(dflag.begin(),dflag.end(),false);",
            "    }",
            "    inline bool should_extend(u32 x)const{return x*2>=cap;}",
            "    inline bool should_shrink(u32 x)const{return 4<cap&&x*10<=cap;}",
            "    inline void extend(){reallocate(cap<<1);}",
            "    inline void shrink(){reallocate(cap>>1);}",
            "    public:",
            "    u32 cap,s;",
            "    vector<Data>data;",
            "    vector<bool>flag,dflag;",
            "    u32 shift;",
            "    static u64 r;",
            "    static constexpr uint32_t DEFAULT_SIZE=4;",
            "    struct iterator{",
            "        u32 i;",
            "        hash_map<Key,Val>*p;",
            "        explicit constexpr iterator():i(0),p(nullptr){}",
            "        explicit constexpr iterator(u32 i,hash_map<Key,Val>*p):i(i),p(p){}",
            "        explicit constexpr iterator(u32 i,const hash_map<Key,Val>*p):i(i),p(const_cast<hash_map<Key,Val>*>(p)){}",
            "        const Data& operator*()const{",
            "            return const_cast<hash_map<Key,Val>*>(p)->data[i];",
            "        }",
            "        Data& operator*(){return p->data[i];}",
            "        Data* operator->(){return &(p->data[i]);}",
            "        friend void swap(iterator&a,iterator&b){swap(a.i,b.i);swap(a.p,b.p);}",
            "        friend bool operator==(const iterator&a,const iterator&b){return a.i==b.i;}",
            "        friend bool operator!=(const iterator&a,const iterator&b){return a.i!=b.i;}",
            "        iterator& operator++(){",
            "        assert(i!=p->cap&&\"iterator overflow\");",
            "        do{",
            "            i++;",
            "            if(i==p->cap)break;",
            "            if(p->flag[i]&&!(p->dflag[i]))break;",
            "        } while(true);",
            "        return *this;",
            "        } ",
            "        iterator operator++(int){",
            "            iterator tmp(*this);",
            "            ++(*this);",
            "            return tmp;",
            "        }",
            "        iterator& operator--(){",
            "            do{",
            "                i--;",
            "                if(p->flag[i]&&!(p->dflag[i]))break;",
            "                assert(i!=0&&\"iterator underflow\");",
            "            } while(true);",
            "            return *this;",
            "        }",
            "        iterator operator--(int){",
            "            iterator tmp(*this);",
            "            --(*this);",
            "            return tmp;",
            "        }",
            "    };",
            "    using itr=iterator;",
            "    explicit hash_map():cap(DEFAULT_SIZE),s(0),data(cap),flag(cap),dflag(cap),shift(62){}",
            "    itr begin()const{",
            "        u32 h=0;",
            "        while(h!=cap){",
            "            if(flag[h]&&!dflag[h])break;",
            "            h++;",
            "        }",
            "        return itr(h,this);",
            "    }",
            "    itr end()const{return itr(this->cap,this);}    ",
            "    friend itr begin(hash_map<Key,Val>&a){return a.begin();}",
            "    friend itr end(hash_map<Key,Val>&a){return a.end();}",
            "    itr find(const Key&key)const{",
            "        u32 h=hash(key);",
            "        while(true){",
            "            if(!flag[h])return this->end();",
            "            if(data[h].first==key){",
            "                if(dflag[h])return this->end();",
            "                return itr(h,this);",
            "            }",
            "            h=(h+1)&(cap-1);",
            "        }",
            "    }",
            "    bool contain(const Key&key)const{return find(key)!=this->end();}",
            "    int count(const Key&key)const{return int(find(key)!=this->end());}",
            "    itr insert(const Data&d){",
            "        u32 h=hash(d.first);",
            "        while(true){",
            "            if(!flag[h]){",
            "                if(should_extend(s+1)){",
            "                    extend();",
            "                    h=hash(d.first);",
            "                    continue;",
            "                }",
            "                data[h]=d;",
            "                flag[h]=true;",
            "                s++;",
            "                return itr(h,this);",
            "            }",
            "            if(data[h].first==d.first){",
            "                if(dflag[h]){",
            "                    data[h]=d;",
            "                    dflag[h]=false;",
            "                    s++;",
            "                }",
            "                return itr(h,this);",
            "            }",
            "            h=(h+1)&(cap-1);",
            "        }",
            "    }",
            "    bool erase(itr it){",
            "        if(it==this->end())return false;",
            "        s--;",
            "        if(should_shrink(s)){",
            "            Data d=data[it.i];",
            "            shrink();",
            "            it=find(d.first);",
            "        }",
            "        int ni=(it.i+1)&(cap-1);",
            "        if(flag[ni]){",
            "            dflag[it.i]=true;",
            "        }",
            "        else{",
            "            flag[it.i]=false;",
            "        }",
            "        return true;",
            "    }",
            "    bool erase(const Key&key){return erase(find(key));}",
            "    bool empty()const{return s==0;}",
            "    u32 size()const{return s;}",
            "    void clear(){",
            "        s=0;",
            "        fill(flag.begin(),flag.end(),false);",
            "        fill(dflag.begin(),dflag.end(),false);",
            "    }",
            "    void reserve(int n){",
            "        if(n<=0)return;",
            "        n=1<<(__lg(n)+2);",
            "        if(cap<u32(n))reallocate(n);",
            "    }",
            "    Val& operator[](const Key&key){",
            "        u32 h=hash(key);",
            "        while(true){",
            "            if(!flag[h]){",
            "                if(should_extend(s+1)){",
            "                    extend();",
            "                    h=hash(key);",
            "                    continue;",
            "                }",
            "                data[h]=Data(key,Val());",
            "                flag[h]=true;",
            "                s++;",
            "                return data[h].second;",
            "            }",
            "            if(data[h].first==key){",
            "                if(dflag[h])data[h].second=Val();",
            "                return data[h].second;",
            "            }",
            "            h=(h+1)&(cap-1);",
            "        }",
            "    }",
            "    bool emplace(const Key&key,const Val&val){",
            "        return insert(Data(key,val));",
            "    }",
            "};",
            "template<typename Key,typename Val>uint64_t hash_map<Key,Val>::r=chrono::duration_cast<chrono::nanoseconds>(chrono::system_clock::now().time_since_epoch()).count();",
        ],
        "description": "hash_map"
    },

    "compress": {
        "prefix": "compress",
        "body": [
            "// 座標圧縮",
            "template<typename T=int> struct Compress{",
            "    private:",
            "        vector<int> vec ; // 元の値の座標圧縮後の値",
            "        unordered_map<T,int> mp ; // 元の値 -> 変換された値",
            "        unordered_map<int,T> np ; // 変換された値 -> 元の値",
            "",
            "        void build(vector<T> A){",
            "            int n = A.size() ;",
            "            vector<T> B(n) ;",
            "            for(int i = 0 ; i < n ; i++) B[i] = A[i] ;",
            "            vec.resize(n) ;",
            "            sort(A.begin(),A.end()) ;",
            "            for(int i = 0 ; i < n ; i++){",
            "                auto it = lower_bound(A.begin(),A.end(),B[i]) ;",
            "                int id = it - A.begin() ;",
            "                vec[i] = id ;",
            "                mp[B[i]] = id;",
            "                np[id] = B[i] ;",
            "            }",
            "        }",
            "",
            "    public:",
            "        Compress(){}",
            "        Compress(vector<T> A) { build(A); }",
            "        size_t size() {return vec.size() ; }",
            "        // 元の値 -> 変換された値",
            "        inline int encrypt(T i) { return mp[i] ; }",
            "        // 変換された値 -> 元の値",
            "        inline T decrypt(int i) { return np[i] ; }",
            "        vector<int> compress() { return vec; }",
            "        vector<int> compress(vector<T> A) { build(A); return vec; }",
            "        inline int operator [] (int i) { return vec[i] ; }",
            "};",
            "",
            "// function               : return              : description",
            "// -----------------------------------------------------",
            "// Compress()             : void          : コンストラクタ",
            "// Compress(vector<ll> A) : void          : コンストラクタ, 座圧する",
            "// encrypt(ll v)          : int           : 元の値 -> 座圧後の値",
            "// decrypt(int v)         : ll            : 座圧後の値 -> 元の値",
            "// compress()             : vector<int>   : 座圧後の値",
            "// operator[i]            : int           : 座圧後の値の vector にアクセスすることが可能",
        ],
        "description": ""
    },


    "SCC": {
        "prefix": "SCC",
        "body": [
            "struct SCC{",
            "    private :",
            "        int n ;",
            "        int gragh_size ;",
            "",
            "        // G       : 既存の有向辺についての情報",
            "        // F       : 既存の有向辺（逆辺）についての情報",
            "        // H       : 新たなグラフ（有向辺）の辺についての情報",
            "        // I       : 新たなグラフ（有向辺）の逆辺についての情報",
            "        // used    : dfsで使ったか",
            "        // reused  : Redfsで使ったか",
            "        // conv    : 新たなノードに変換する",
            "        // volume  : 新たなノードに集約されたノード個数",
            "        // cycle   : 新たなノードに集約されたノードがサイクルを持っていたか",
            "        // go      : v -> u に行ったことがあるか",
            "        // restore : 新たなノードに集約された元々のノード一覧",
            "",
            "        vector<vector<int>> G , F , H , I;",
            "        vector<int> order ;",
            "        vector<bool> used , reused ;",
            "        vector<int> conv ;",
            "        vector<int> volume ;",
            "        vector<vector<int>> restore ;",
            "        vector<bool> cycle;",
            "        set<P> go ;",
            "",
            "        void clear_(){",
            "            n = 0;",
            "            G.clear() ; F.clear() ; H.clear(); I.clear();",
            "            used.clear() ; reused.clear() ;",
            "            conv.clear() ;",
            "            volume.clear() ;",
            "            cycle.clear();",
            "            order.clear();",
            "            restore.clear();",
            "            go.clear();",
            "            gragh_size = 0 ;",
            "        }",
            "",
            "        void init_(int n_){",
            "            n = n_ ;",
            "            G.resize(n) ; F.resize(n) ;",
            "            used.resize(n,false) ; reused.resize(n,false) ;",
            "            conv.resize(n) ;",
            "            volume.resize(n,0) ;",
            "            cycle.resize(n,false) ;",
            "            gragh_size = 0 ;",
            "        }",
            "",
            "",
            "        inline void dfs(int v){",
            "            used[v] = true ;",
            "            for(int i = 0 ; i < G[v].size() ; i++){",
            "                int u = G[v][i] ;",
            "                if(used[u]) continue ;",
            "                dfs(u) ;",
            "            }",
            "            order.push_back(v) ;",
            "        }",
            "",
            "        inline void Redfs(int s , int v){",
            "            reused[v] = true ;",
            "            conv[v] = s ;",
            "            volume[s]++ ;",
            "            if(!cycle[s] && volume[s] > 1) cycle[s] = true;",
            "            for(int i = 0 ; i < F[v].size() ; i++){",
            "                int u = F[v][i] ;",
            "                if(u == v) cycle[s] = true;",
            "                if(reused[u]) continue ;",
            "                Redfs(s,u) ;",
            "            }",
            "        }",
            "",
            "        void build_(){",
            "            // 処理1 : 1度目のdfs",
            "            for(int i = 0 ; i < n ; i++) if(!used[i]) dfs(i) ;",
            "            // 処理2 : 2度目のdfs",
            "            for(int i = 0 ; i < n ; i++) {",
            "                int v = order[n-1-i] ;",
            "                if(reused[v]) continue ;",
            "                Redfs(gragh_size,v) ;",
            "                gragh_size++ ;",
            "            }",
            "            H.resize(gragh_size) ;",
            "            I.resize(gragh_size) ;",
            "            restore.resize(gragh_size) ;",
            "            // 処理3 : 新しいグラフを作成する",
            "            for(int v = 0 ; v < n ; v++){",
            "                restore[conv[v]].push_back(v) ;",
            "                for(int u : G[v]){",
            "                    int from = conv[v] , to = conv[u] ;",
            "                    if(from == to) continue ;",
            "                    // if(go.count(P(from,to))) continue ;",
            "                    // go.insert(P(from,to));",
            "                    H[from].push_back(to) ;",
            "                    I[to].push_back(from) ;",
            "                }",
            "            }",
            "        }",
            "",
            "        inline void add_edge_(int v , int u) {",
            "            G[v].push_back(u) ;",
            "            F[u].push_back(v) ;",
            "        }",
            "",
            "    public :",
            "        // n_ : グラフのノード数",
            "        SCC(){}",
            "        SCC(int n_){ init(n_) ; }",
            "        void init(int n_) { init_(n_) ; }",
            "        void clear() { clear_() ; }",
            "        void build() { build_() ; }",
            "        void add_edge(int v , int u) { add_edge_(v,u) ; }",
            "        int convert(int v) { return conv[v] ; } // ノード v は新たなグラフ H 上においてどのノードに変化するか",
            "        bool has_cycle(int v){ return cycle[v] ; }",
            "        int get_integrated_node_size(int v){ return volume[v] ; }",
            "        vector<vector<int>> get_integrated_node() { return restore ; }",
            "        vector<int> get_integrated_node(int v) { return restore[v] ; }",
            "        int get_new_gragh_size(){ return gragh_size ; }",
            "        vector<vector<int>> get_new_gragh() { return H ; }",
            "        int get_new_rev_gragh_size(){ return gragh_size ; }",
            "        vector<vector<int>> get_new_rev_gragh() { return I ; }",
            "} ;",
            "",
            "// function                    : return              : description",
            "// -----------------------------------------------------------------",
            "// constructor(int n)          :                     : 元のグラフのサイズが n である構造体を作る",
            "// constructor()               :                     : コンストラクタを行わない場合に利用",
            "// clear                       : void                : メモリを解放する",
            "// init(int n)                 : void                : 元のグラフのサイズが n である構造体を作る",
            "// build()                     : void                : ビルドを行う",
            "// add_edge(u,v)               : void                : 有向辺グラフ G と逆辺グラフ F を張る",
            "// convert(u)                  : int                 : 元のグラフ G のノード u が新たなグラフ H におけるどのノードに変異したか",
            "// has_cycle()                 : vector<int>         : 新たなグラフ H のノード u がサイクルを持っているか",
            "// get_integrated_node_size(u) : int                 : 新たなグラフ H のノード (0-indexed) に元のグラフ G の幾つ分のノードが集約されているか",
            "// get_integrated_node(u)      : vector<int>         : 新たなグラフ H のノード u に集約された元のグラフ G のノードリスト",
            "// get_integrated_node()       : vector<vector<int>> : 新たなグラフ H に集約されたノードリスト",
            "// get_new_gragh_size()        : int                 : 新たなグラフ H のノード数, 新しいグラフのノード番号は 0-indexed {0,1,2,3,4,..,gragh_size-1}",
            "// get_new_gragh()             : vector<vector<int>> : 新たなグラフ H",
            "// get_new_rev_gragh()         : vector<vector<int>> : 新たなグラフ H の逆辺",
            "// ------------------------------------------------------------------",
            "// *注意* SCCにより生成された新たなグラフ H は 0-indexedのグラフである",
            "// このままコピペ奨励",
            "",
            "// ------------------------------------------------------- //",
            "// 不安であれば ABC245F sample1, 典型90 021, div3 731G で確認  //",
            "// ------------------------------------------------------- //",
        ],
        "description": "scc"
    },

    "modint": {
        "prefix": "modint",
        "body": [
            "const int mod = 998244353 ;",
            "",
            "template< int mod >",
            "struct ModInt {",
            "    int x;",
            "",
            "    ModInt() : x(0) {}",
            "",
            "    ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}",
            "",
            "    ModInt &operator+=(const ModInt &p) {",
            "        if((x += p.x) >= mod) x -= mod;",
            "        return *this;",
            "    }",
            "",
            "    ModInt &operator-=(const ModInt &p) {",
            "        if((x += mod - p.x) >= mod) x -= mod;",
            "        return *this;",
            "    }",
            "",
            "    ModInt &operator*=(const ModInt &p) {",
            "        x = (int) (1LL * x * p.x % mod);",
            "        return *this;",
            "    }",
            "",
            "    ModInt &operator/=(const ModInt &p) {",
            "        *this *= p.inverse();",
            "        return *this;",
            "    }",
            "",
            "    ModInt operator-() const { return ModInt(-x); }",
            "",
            "    ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }",
            "",
            "    ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }",
            "",
            "    ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }",
            "",
            "    ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }",
            "",
            "    bool operator==(const ModInt &p) const { return x == p.x; }",
            "",
            "    bool operator!=(const ModInt &p) const { return x != p.x; }",
            "",
            "    ModInt inverse() const {",
            "        int a = x, b = mod, u = 1, v = 0, t;",
            "        while(b > 0) {",
            "            t = a / b;",
            "            swap(a -= t * b, b);",
            "            swap(u -= t * v, v);",
            "        }",
            "        return ModInt(u);",
            "    }",
            "",
            "    ModInt pow(int64_t n) const {",
            "        ModInt ret(1), mul(x);",
            "        while(n > 0) {",
            "            if(n & 1) ret *= mul;",
            "            mul *= mul;",
            "            n >>= 1;",
            "        }",
            "        return ret;",
            "    }",
            "",
            "    friend ostream &operator<<(ostream &os, const ModInt &p) {",
            "        return os << p.x;",
            "    }",
            "",
            "    friend istream &operator>>(istream &is, ModInt &a) {",
            "        int64_t t;",
            "        is >> t;",
            "        a = ModInt< mod >(t);",
            "        return (is);",
            "    }",
            "",
            "    static int get_mod() { return mod; }",
            "};",
            "",
            "using modint = ModInt< mod >;",
        ],
        "description": "modint"
    },

    "TopologicalSort": {
        "prefix": "TopologicalSort",
        "body": [
            "struct TopologicalSort{",
            "",
            "    private :",
            "        int n ; // ノード数",
            "        vector<int> order ; // トポロジカルソート後のノードの並び",
            "        vector<int> start ; // 始点ノード",
            "        vector<int> end ; // 終点ノード",
            "        vector<vector<int>> G ;",
            "",
            "        vector<int> in ;",
            "",
            "        // トポロジカルソートを実施",
            "        void build_(bool inner_sort){",
            "			in.resize(n,0) ;",
            "            for(int i = 0 ; i < n ; i++){",
            "                for(int u : G[i]) in[u]++ ;",
            "            }",
            "			if(inner_sort){",
            "				set<int> st ;",
            "				for(int i = 0 ; i < n ; i++) if(in[i] == 0) {",
            "					st.insert(i) ;",
            "					start.push_back(i) ;",
            "				}",
            "				while(!st.empty()){",
            "					auto it = st.begin() ;",
            "					int v = *it ; st.erase(it) ;",
            "					order.push_back(v) ;",
            "					if(G[v].empty()) end.push_back(v) ;",
            "					for(int u : G[v]) {",
            "						in[u]-- ;",
            "						if(in[u] == 0) st.insert(u) ;",
            "					}",
            "				}",
            "			}",
            "			else{",
            "				queue<int> que ;",
            "				for(int i = 0 ; i < n ; i++) if(in[i] == 0) {",
            "					que.push(i) ;",
            "					start.push_back(i) ;",
            "				}",
            "				while(!que.empty()){",
            "					int v = que.front() ; que.pop() ;",
            "					order.push_back(v) ;",
            "					if(G[v].empty()) end.push_back(v) ;",
            "					for(int u : G[v]) {",
            "						in[u]-- ;",
            "						if(in[u] == 0) que.push(u) ;",
            "					}",
            "				}",
            "			}",
            "        }",
            "",
            "        void add_edge_(int u , int v){",
            "            G[u].push_back(v) ;",
            "        }",
            "",
            "        // 閉路判定: true: 閉路あり, false: 閉路なし, O(1)",
            "        bool has_cycle_(){",
            "            int m = order.size() ;",
            "            if(n != m) return true ;",
            "            return false ;",
            "        }",
            "",
            "    public :",
            "",
            "        // コンストラクタ",
            "        TopologicalSort(int n_){",
            "            n = n_ ;",
            "            G.resize(n) ;",
            "        }",
            "",
            "        void build(bool inner_sort = true) { build_(inner_sort) ; }",
            "        void add_edge(int u , int v) { add_edge_(u,v) ; }",
            "        bool has_cycle() { return has_cycle_() ; }",
            "        vector<int> get_start_node() { return start ; }",
            "        vector<int> get_end_node() { return end ; }",
            "        vector<int> sorted() { return order ; }",
            "        vector<vector<int>> get_gragh() { return G ; }",
            "};",
            "",
            "// function         : return              : description",
            "// -----------------------------------------------------",
            "// build(bool type) : void                : ビルドする (辺を張った後にビルドすることに注意) type が trueの場合,生成できるトポロジカルソートの中で辞書順最小なものを生成",
            "// add_edge(u,v)    : void                : u -> v に有向辺を張る",
            "// has_cycle()      : bool                : サイクルをもつか",
            "// get_start_node() : vector<int>         : 処理が一番最初に行割れる可能性のあるノードリスト",
            "// get_end_node()   : vector<int>         : 処理が一番最後に行われる可能性のあるノードリスト",
            "// sorted()         : vector<int>         : トポロジカルソートされたノード",
            "// get_gragh()      : vector<vector<int>> : グラフ G を返す",
            "// *注意* 取り敢えず全てをコピペすることを奨励",
            "",
            "// ---------------------------------- //",
            "// 不安であれば ABC216D, ABC223D で確認  //",
            "// ---------------------------------- //",
        ],
        "description": ""
    },


    "RunLengthCompression": {
        "prefix": "RunLengthCompression",
        "body": [
            "template<typename T>",
            "struct RunLengthCompression {",
            "    private:",
            "        vector<pair<T,int>> res ;",
            "        vector<T> A_ , A ;",
            "        int n ;",
            "        void build_(){",
            "            A.resize(n+1) ;",
            "            for(int i = 0 ; i < n ; i++) A[i] = A_[i] ;",
            "            int cnt = 1 ;",
            "            for(int i = 0 ; i < n ; i++){",
            "                if(A[i] == A[i+1]) cnt++ ;",
            "                else{",
            "                    res.push_back(pair<T,int>(A[i],cnt)) ;",
            "                    cnt = 1 ;",
            "                }",
            "            }",
            "        }",
            "    public:",
            "        RunLengthCompression(vector<T> _A): A_(_A), n(_A.size()) {} ;",
            "        void build() { build_() ; }",
            "        vector<pair<T,int>> get_RLC() { return res ; }",
            "};",
            "",
            "// ----------------------------",
            "// function                           : return              : description",
            "// -----------------------------------------------------",
            "// RunLengthCompression(vector<T> _A) :                     : コンストラクタ",
            "// build()                            : void                : ビルドする（必ず行うこと）",
            "// get_RLC()                          : vector<pair<T,int>> : ランレングス圧縮の結果を返す",
            "// ----------------------------",
            "// *注意*",
            "// ----------------------------",
            "// build をちゃんと行うこと",
        ],
        "description": ""
    },

    "eratosthenes": {
        "prefix": "eratosthenes",
        "body": [
            "struct Eratosthenes{",
            "",
            "    private :",
            "        int n ;",
            "        vector<int> factor ; // factor[i]: i を割ることのできる素数",
            "        vector<int> prime ; // 素数",
            "        vector<bool> isprime; // 素数判定",
            "        vector<int> mobius; // メビウス関数",
            "",
            "        void build(){",
            "            for(int i = 2 ; i < n ; ++i){",
            "                if(factor[i] != -1) continue ;",
            "                prime.push_back(i) ;",
            "                isprime[i] = true ;",
            "                for(int j = i ; j < n ; j += i) {",
            "                    factor[j] = i ;",
            "                    if((j / i) % i == 0) mobius[j] = 0;",
            "                    else mobius[j] = -mobius[j];",
            "                }",
            "",
            "            }",
            "        }",
            "",
            "        void init_(int n_){",
            "            n = max(n_,303030) ;",
            "            factor.resize(n,-1) ;",
            "            isprime.resize(n,false) ;",
            "            mobius.resize(n,1);",
            "            build() ;",
            "        }",
            "        ",
            "        // 素因数分解 20 -> { (5,1), (2,2) }",
            "        vector<P> prime_factorization_(int k){",
            "            vector<P> res ;",
            "            while(k != 1){",
            "                int ex = 0 ;",
            "                int d = factor[k] ;",
            "                while(k % d == 0){",
            "                    k /= d ;",
            "                    ex++ ;",
            "                }",
            "                res.push_back(P(d,ex)) ;",
            "            }",
            "            return res ;",
            "        }",
            "",
            "        // 素因数分解の素因数のみ 20 -> { 5, 2 }",
            "        vector<int> prime_factor_(int k){",
            "            vector<int> res ;",
            "            while(k != 1){",
            "                int ex = 0 ;",
            "                int d = factor[k] ;",
            "                while(k % d == 0){",
            "                    k /= d ;",
            "                    ex++ ;",
            "                }",
            "                res.push_back(d) ;",
            "            }",
            "            return res ;",
            "        }",
            "",
            "        // オイラーのファイ関数",
            "        int get_euler_phi_(int k) {",
            "            int euler = k ;",
            "            while(k != 1){",
            "                int d = factor[k] ;",
            "                while(k % d == 0) k /= d ;",
            "                euler -= euler / d ;",
            "            }",
            "            return euler ;",
            "        }",
            "",
            "        // 高速ゼータ変換",
            "        template<typename T> vector<T> zeta_transform_(vector<T> f){",
            "            int n = f.size();",
            "            for(int i = 2 ; i < n ; i++){",
            "                if(!isprime[i]) continue;",
            "                for(int j = (n - 1) / i ; j > 0 ; --j){",
            "                    f[j] += f[j * i];",
            "                }",
            "            }",
            "            return f;",
            "        }",
            "",
            "        // 高速メビウス変換",
            "        template<typename T> vector<T> mobius_transform_(vector<T> F){",
            "            int n = F.size();",
            "            for(int i = 2 ; i < n ; ++i){",
            "                if(!isprime[i]) continue;",
            "                for(int j = 1 ; j * i < n ; ++j){",
            "                    F[j] -= F[j * i];",
            "                }",
            "            }",
            "            return F;",
            "        }",
            "",
            "        template<typename T> vector<T> gcd_convolution_(vector<T> f, vector<T> g){",
            "            int n = max((int)f.size(), (int)g.size());",
            "            vector<T> F = zeta_transform_(f);",
            "            vector<T> G = zeta_transform_(g);",
            "            vector<T> H(n);",
            "            for(int i = 1 ; i < min((int)F.size(), (int)G.size()) ; ++i) H[i] = F[i] * G[i];",
            "            return mobius_transform_(H);",
            "        }",
            "",
            "    public :",
            "        Eratosthenes(){}",
            "        Eratosthenes(int n_){ init_(n_); }",
            "        void init(int n_) { init_(n_); }",
            "        vector<P> prime_factorization(int k) { return prime_factorization_(k); }",
            "        vector<int> prime_factor(int k) { return prime_factor_(k); }",
            "        int get_euler_phi(int k) { return get_euler_phi_(k); }",
            "        int get_mobius(int k) { return mobius[k]; }",
            "        vector<int> get_prime() { return prime ; }",
            "        bool is_prime(int i) { return isprime[i] ; }",
            "        template<typename T> vector<T> zeta_transform(vector<T> f) { return zeta_transform_(f); }",
            "        template<typename T> vector<T> mobius_transform(vector<T> F) { return mobius_transform_(F); }",
            "        template<typename T> vector<T> gcd_convolution(vector<T> f, vector<T> g) { return gcd_convolution_(f, g); }",
            "};",
        ],
        "description": ""
    },

    "FFT": {
        "prefix": "FFT",
        "body": [
            "const ld pi = 3.1415926535 ;",
            "",
            "struct FFT{",
            "    int n ;",
            "    vector<complex<ld>> vec , X , Y ;",
            "    FFT(vector<ll> A , vector<ll> B){",
            "        int n1 = A.size() , n2 = B.size() , n_ = n1 + n2 - 1 ;",
            "        n = 1 ;",
            "        while(n < n_) n *= 2 ;",
            "        X.resize(n,0) , Y.resize(n,0) ;",
            "        for(int i = 0 ; i < n1 ; i++) X[i] = complex<ld>(A[i],0) ;",
            "        for(int i = 0 ; i < n2 ; i++) Y[i] = complex<ld>(B[i],0) ;",
            "        build() ;",
            "    }",
            "    // ビルドする（畳み込み→逆変換） ",
            "    void build(){",
            "        // 畳み込み",
            "        vector<complex<ld>> V = convolution(X,Y) ;",
            "        // 逆変換",
            "        vec = ifft(V) ;",
            "    }",
            "    // バタフライ演算を行うために配置を変換",
            "    inline void arrangeIndexForBatafly(vector<complex<ld>> &A , int logn){",
            "        for (int i = 0; i < n; i++) {",
            "            int j = 0;",
            "            for (int k = 0; k < logn; k++) j |= (i >> k & 1) << (logn - 1 - k);",
            "            if (i < j) swap(A[i], A[j]);",
            "        }",
            "    }",
            "    // FFT, IFFT のロジック",
            "    inline vector<complex<ld>> sub_fft(vector<complex<ld>> A , bool inverse){",
            "        int logn = 0 ;",
            "        for(int i = 0 ; 1 << i < n ; i++) logn++ ;",
            "        // バタフライ演算",
            "        arrangeIndexForBatafly(A,logn) ;",
            "        for(int block = 1 ; block < n ; block *= 2){",
            "            // block内 の j 番目に対する処理",
            "            for(int j = 0 ; j < block ; j++){",
            "                // w : 重み , v : 1 or -1",
            "                ld v = inverse == true ? 1.0 : -1.0 ;",
            "                complex<ld> w = polar((ld)1.0,(2*pi) / (2*block) * j * v) ;",
            "                for(int i = 0 ; i < n ; i += 2 * block){",
            "                    complex<ld> s = A[j+i] ;",
            "                    complex<ld> t = A[j+i+block] * w ;",
            "                    A[j + i] = s + t ;",
            "                    A[j + i + block] = s - t ;",
            "                }",
            "            }",
            "        }",
            "        if(inverse) for(int i = 0 ; i < n ; i++) A[i] /= n ;",
            "        return A ;",
            "    }",
            "    // 高速フーリエ変換（FFT）",
            "    inline vector<complex<ld>> fft(vector<complex<ld>> A) { return sub_fft(A,false) ; }",
            "    // 逆高速フーリエ変換（IFFT）",
            "    inline vector<complex<ld>> ifft(vector<complex<ld>> A) { return sub_fft(A,true) ; }",
            "    // 畳み込み（Comvolution）を行う",
            "    inline vector<complex<ld>> convolution(vector<complex<ld>> A , vector<complex<ld>> B){",
            "        X = fft(A) , Y = fft(B) ;",
            "        vector<complex<ld>> V(n,0) ;",
            "        for(int i = 0 ; i < n ; i++) V[i] = X[i] * Y[i] ;",
            "        return V ;",
            "    }",
            "    inline ll operator [] (int i) { return (ll)(vec[i].real()+0.5) ; }",
            "    size_t fft_size() { return n ; } // 2の冪乗が返ってくる",
            "};",
        ],
        "description": ""
    },

    "NTT": {
        "prefix": "NTT",
        "body": [
            "const int mod = 998244353 ;",
            "",
            "template< int mod >",
            "struct ModInt {",
            "    int x;",
            "",
            "    ModInt() : x(0) {}",
            "",
            "    ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}",
            "",
            "    ModInt &operator+=(const ModInt &p) {",
            "        if((x += p.x) >= mod) x -= mod;",
            "        return *this;",
            "    }",
            "",
            "    ModInt &operator-=(const ModInt &p) {",
            "        if((x += mod - p.x) >= mod) x -= mod;",
            "        return *this;",
            "    }",
            "",
            "    ModInt &operator*=(const ModInt &p) {",
            "        x = (int) (1LL * x * p.x % mod);",
            "        return *this;",
            "    }",
            "",
            "    ModInt &operator/=(const ModInt &p) {",
            "        *this *= p.inverse();",
            "        return *this;",
            "    }",
            "",
            "    ModInt operator-() const { return ModInt(-x); }",
            "",
            "    ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }",
            "",
            "    ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }",
            "",
            "    ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }",
            "",
            "    ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }",
            "",
            "    bool operator==(const ModInt &p) const { return x == p.x; }",
            "",
            "    bool operator!=(const ModInt &p) const { return x != p.x; }",
            "",
            "    ModInt inverse() const {",
            "        int a = x, b = mod, u = 1, v = 0, t;",
            "        while(b > 0) {",
            "            t = a / b;",
            "            swap(a -= t * b, b);",
            "            swap(u -= t * v, v);",
            "        }",
            "        return ModInt(u);",
            "    }",
            "",
            "    ModInt pow(int64_t n) const {",
            "        ModInt ret(1), mul(x);",
            "        while(n > 0) {",
            "            if(n & 1) ret *= mul;",
            "            mul *= mul;",
            "            n >>= 1;",
            "        }",
            "        return ret;",
            "    }",
            "",
            "    friend ostream &operator<<(ostream &os, const ModInt &p) {",
            "        return os << p.x;",
            "    }",
            "",
            "    friend istream &operator>>(istream &is, ModInt &a) {",
            "        int64_t t;",
            "        is >> t;",
            "        a = ModInt< mod >(t);",
            "        return (is);",
            "    }",
            "",
            "    static int get_mod() { return mod; }",
            "};",
            "",
            "using modint = ModInt< mod >;",
            "",
            "struct NTT{",
            "    private:",
            "        int n , logn = 0;",
            "        modint BASE = 3 ;",
            "        vector<modint> vec , X , Y ;",
            "        vector<vector<modint>> ROOT , INV_ROOT ;",
            "",
            "        // ビルドする（畳み込み→逆変換） ",
            "        void build(){",
            "            // 畳み込み",
            "            vector<modint> V = convolution(X,Y) ;",
            "            // 逆変換",
            "            vec = ifft(V) ;",
            "        }",
            "        // バタフライ演算を行うために配置を変換",
            "        inline void arrangeIndexForBatafly(vector<modint> &A , int logn){",
            "            for (int i = 0; i < n; i++) {",
            "                int j = 0;",
            "                for (int k = 0; k < logn; k++) j |= (i >> k & 1) << (logn - 1 - k);",
            "                if (i < j) swap(A[i], A[j]);",
            "            }",
            "        }",
            "        // FFT, IFFT のロジック",
            "        inline vector<modint> sub_fft(vector<modint> A , bool inverse){",
            "            // バタフライ演算",
            "            arrangeIndexForBatafly(A,logn) ;",
            "            int lg = 1 ;",
            "            for(int block = 1 ; block < n ; block *= 2){",
            "                // block内 の j 番目に対する処理",
            "                for(int j = 0 ; j < block ; j++){",
            "                    // w , v : 重み",
            "                    modint w = inverse ? ROOT[lg][j] : INV_ROOT[lg][j] ;",
            "                    modint v = inverse ? ROOT[lg][j+block] : INV_ROOT[lg][j+block] ;",
            "                    for(int i = 0 ; i < n ; i += 2 * block){",
            "                        modint s = A[j+i] ;",
            "                        modint t = A[j+i+block] ;",
            "                        A[j + i] = s + t * w ;",
            "                        A[j + i + block] = s + t * v ;",
            "                    }",
            "                }",
            "                lg++ ;",
            "            }",
            "            if(inverse) for(int i = 0 ; i < n ; i++) A[i] /= n ;",
            "            return A ;",
            "        }",
            "        // 高速数論変換（NTT）",
            "        inline vector<modint>  fft(vector<modint> A) { return sub_fft(A,false)  ; }",
            "        // 逆高速数論変換（INTT）",
            "        inline vector<modint> ifft(vector<modint> A) { return sub_fft(A,true) ; }",
            "        // 畳み込み（Comvolution）を行う",
            "        inline vector<modint> convolution(vector<modint> A , vector<modint> B){",
            "            X = fft(A) , Y = fft(B) ;",
            "            vector<modint> V(n,0) ;",
            "            for(int i = 0 ; i < n ; i++) V[i] = X[i] * Y[i] ;",
            "            return V ;",
            "        }",
            "",
            "    public:",
            "        NTT(vector<modint> A , vector<modint> B){",
            "            BASE = BASE.pow(119) ;",
            "            int n1 = A.size() , n2 = B.size() , n_ = n1 + n2 - 1 ;",
            "            n = 1 ;",
            "            while(n < n_) n *= 2 , logn++ ;",
            "            X.resize(n,0) , Y.resize(n,0) ;",
            "            for(int i = 0 ; i < n1 ; i++) X[i] = A[i] ;",
            "            for(int i = 0 ; i < n2 ; i++) Y[i] = B[i] ;",
            "",
            "            rep(i,logn+1) {",
            "                vector<modint> pwr , ipwr ;",
            "                modint POW = BASE.pow(1<<(23-i)) ;",
            "                modint INV_POW = POW.inverse() ;",
            "                modint powval = 1 , inv_powval = 1 ;",
            "                rep(j,(1<<i)+1) {",
            "                    pwr.push_back(powval) ;",
            "                    powval *= POW ;",
            "                }",
            "                rep(j,(1<<i)+1) {",
            "                    ipwr.push_back(inv_powval) ;",
            "                    inv_powval *= INV_POW ;",
            "                }",
            "                ROOT.push_back(pwr) ;",
            "                INV_ROOT.push_back(ipwr) ;",
            "            }",
            "            build() ;",
            "        }",
            "        inline modint operator [] (int i) { return vec[i] ; }",
            "        size_t fft_size() { return n ; } // 2の冪乗が返ってくる",
            "        vector<modint> get_fft() { return vec ; }",
            "};",
        ],
        "description": ""
    },

    "doubling": {
        "prefix": "doubling",
        "body": [
            "struct Doubling {",
            "    private:",
            "        const ll INF = LLONG_MAX ;",
            "",
            "        int n ;",
            "        vector<vector<int>> dp ;",
            "        vector<vector<ll>> S ;",
            "",
            "        void init(vector<int> A_ , vector<ll> T) {",
            "            n = A_.size() ;",
            "            dp.resize(60,vector<int>(n)) ;",
            "            S.resize(60,vector<ll>(n)) ;",
            "            rep(i,n){",
            "                dp[0][i] = A_[i] ;",
            "                S[0][i] = T[i] ;",
            "            }",
            "        }",
            "",
            "        void build_(int count = 59){",
            "            rep(i,count) {",
            "                rep(j,n) {",
            "                    dp[i+1][j] = dp[i][dp[i][j]] ;",
            "                    if(INF - S[i][j] <= S[i][dp[i][j]]) S[i+1][j] = INF ;",
            "                    else S[i+1][j] = S[i][j] + S[i][dp[i][j]] ;",
            "                }",
            "            }",
            "        }",
            "",
            "        int get_index_(int v , ll k) {",
            "            int cnt = 0 ;",
            "            while(k > 0){",
            "                if(k & 1) v = dp[cnt][v] ;",
            "                cnt++ ;",
            "                k >>= 1 ;",
            "            }",
            "            return v ;",
            "        }",
            "",
            "        ll get_sum_(int v , ll k) {",
            "            ll sum = 0 ;",
            "            int cnt = 0 ;",
            "            while(k > 0){",
            "                if(k & 1) {",
            "                    if(INF - sum <= S[cnt][v]) sum = INF ;",
            "                    else sum += S[cnt][v] ;",
            "                    v = dp[cnt][v] ;",
            "                }",
            "                cnt++ ;",
            "                k >>= 1 ;",
            "            }",
            "            return sum ;",
            "        }",
            "",
            "    public:",
            "        // A[i] = j : i が j に遷移する",
            "        // T[i] = x : i が j に遷移する時に得る個数(通りの数)が x である",
            "        Doubling(vector<int> A_ , vector<ll> T = vector<ll>(202020,0)){ init(A_,T) ; }",
            "",
            "        void build() { build_() ; }",
            "        int get_index(int v , ll k) { return get_index_(v,k) ; }",
            "        int get_next_moving_index(int v) { return dp[0][v] ; }",
            "        ll get_sum(int v , ll k) { return get_sum_(v,k) ; }",
            "        ll get_next_moving_sum(int v) { return S[0][v] ; }",
            "};",
        ],
        "description": ""
    },


    "matrix": {
        "prefix": "matrix",
        "body": [
            "template<typename T = ll> struct Matrix{",
            "    int row, col;",
            "    vector<vector<T>> mat ;",
            "",
            "    private:",
            "        void init_(vector<vector<T>> A){",
            "            row = A.size();",
            "            col = A[0].size();",
            "            mat = A;",
            "        }",
            "        ",
            "        void init_(vector<T> A, bool row_matrix = false){",
            "            if(row_matrix) {",
            "                col = (int)A.size();",
            "                row = 1;",
            "                mat.resize(1);",
            "                mat[0] = A;",
            "            }",
            "            else {",
            "                col = 1;",
            "                row = (int)A.size();",
            "                mat.resize(row,vector<T>(1));",
            "                rep(i,row) mat[i][0] = A[i];",
            "            }",
            "        }",
            "",
            "        Matrix<T> pow_(ll k){",
            "            assert(row == col);",
            "            vector<vector<T>> E(row,vector<T>(row,0));",
            "            rep(i,row) rep(j,row) if(i == j) E[i][j] = 1;",
            "            Matrix<T> res(E);",
            "            Matrix<T> X(mat);",
            "            while(k > 0){",
            "                if(k & 1) res *= X;",
            "                X *= X;",
            "                k >>= 1 ;",
            "            }",
            "            return res;",
            "        }",
            "",
            "        void transpose_() {",
            "            vector<vector<T>> res(col,vector<T>(row));",
            "            rep(i,row) rep(j,col) res[j][i] = mat[i][j];",
            "            mat = res;",
            "            swap(row,col);",
            "        }",
            "",
            "        void concat_col_(vector<T> &Y) {",
            "            Matrix X(Y);",
            "            concat_col_(X);",
            "        }",
            "        void concat_col_(vector<vector<T>> &Y) {",
            "            Matrix X(Y);",
            "            concat_col_(X);",
            "        }",
            "        void concat_col_(Matrix &Y) {",
            "            assert((int)Y.row == row);",
            "            col += Y.col;",
            "            rep(i,row) {",
            "                rep(j,Y.col) mat[i].push_back(Y.mat[i][j]);",
            "            }",
            "        }",
            "",
            "        void concat_row_(vector<T> &Y) {",
            "            Matrix X(Y,true);",
            "            concat_row_(X);",
            "        }",
            "        void concat_row_(vector<vector<T>> &Y) {",
            "            Matrix X(Y);",
            "            concat_row_(X);",
            "        }",
            "        void concat_row_(Matrix &Y) {",
            "            assert((int)Y.col == col);",
            "            row += Y.row;",
            "            rep(i,Y.row) mat.push_back(Y.mat[i]);",
            "        }",
            "",
            "        void print_() {",
            "            rep(i,row){",
            "                rep(j,col) cout << mat[i][j] << \" \"; cout << endl;",
            "            }",
            "        }",
            "",
            "    public:",
            "",
            "        inline Matrix &operator+=(const Matrix Y) {",
            "            rep(i,row) rep(j,col) mat[i][j] += Y.mat[i][j];",
            "            return *this ;",
            "        }",
            "",
            "        inline Matrix &operator-=(const Matrix Y) {",
            "            rep(i,row) rep(j,col) mat[i][j] -= Y.mat[i][j];",
            "            return *this ;",
            "        }",
            "",
            "        inline Matrix &operator*=(const Matrix Y) {",
            "            int x = row, y = Y.col, n = col;",
            "            vector<vector<T>> res(x,vector<T>(y));",
            "            rep(i,x) rep(j,y) rep(k,n) res[i][j] += mat[i][k] * Y.mat[k][j];",
            "            swap(mat,res);",
            "            return *this ;",
            "        }",
            "",
            "        inline Matrix operator-() const {",
            "            rep(i,row) rep(j,col) mat[i][j] *= -1;",
            "            return *this ;",
            "        }",
            "",
            "        inline Matrix operator+(const Matrix Y) const { return Matrix(*this) += Y; }",
            "",
            "        inline Matrix operator-(const Matrix Y) const { return Matrix(*this) -= Y; }",
            "",
            "        inline Matrix operator*(const Matrix Y) const { return Matrix(*this) *= Y; }",
            "",
            "        inline bool operator==(const Matrix Y) const { return mat == Y.mat; }",
            "",
            "        inline bool operator!=(const Matrix Y) const { return mat != Y.mat; }",
            "",
            "        inline vector<T>&operator[](int i) { return mat[i] ; }",
            "",
            "        Matrix(int n): row(n), col(0) { mat.resize(row); }",
            "        Matrix(vector<T> A, bool row_matrix = false) { init_(A, row_matrix); }",
            "        Matrix(vector<vector<T>> A){ init_(A); }",
            "        void init(vector<T> A, bool row_matrix = false) { init_(A, row_matrix); }",
            "        void init(vector<vector<T>> A) { init_(A); }",
            "        size_t row_size() { return row; }",
            "        size_t col_size() { return col; }",
            "        Matrix pow(ll k){ return pow_(k); }",
            "        void transpose() { transpose_(); }",
            "        void concat_col(vector<vector<T>> &Y) { concat_col_(Y); }",
            "        void concat_col(vector<T> &Y) { concat_col_(Y); }",
            "        void concat_col(Matrix &Y) { concat_col_(Y); }",
            "        void concat_row(vector<vector<T>> &Y) { concat_row_(Y); }",
            "        void concat_row(vector<T> &Y) { concat_row_(Y); }",
            "        void concat_row(Matrix &Y) { concat_row_(Y); }",
            "        void print() { print_(); }",
            "};",
            "",
            "// function                     : return              : description",
            "// -----------------------------------------------------",
            "// init(vector<T>, row_matrix)    : void                : 1次元ベクトルに対して行列化する, 列行列か行行列を選択できる",
            "// init(vector<vector<T>>)        : void                : 2次元ベクトルに対して行列化する",
            "// row_size()                     : void                : 行の大きさ",
            "// col_size()                     : void                : 列の大きさ",
            "// pow(k)                         : Matrix              : 行列をk乗する(n * n 行列であること)",
            "// transpose()                    : void                : 転置する",
            "// concat_col(vector<vector<T>>)  : void                : 列に関して結合する",
            "// concat_col(vector<T>)          : void                : 列に関して結合する",
            "// concat_col(Matrix)             : void                : 列に関して結合する",
            "// concat_row(vector<vector<T>>)  : void                : 列に関して結合する",
            "// concat_row(vector<T>)          : void                : 列に関して結合する",
            "// concat_row(Matrix)             : void                : 列に関して結合する",
            "// print()                        : void                : 行列を出力する",
        ],
        "description": ""
    },

    "maxflow": {
        "prefix": "maxflow",
        "body": [
            "struct Dinic{",
            "    private:",
            "        static const ll inf = LLONG_MAX;",
            "        struct edge {",
            "            int to, rev;",
            "            ll cap ;",
            "        };",
            "",
            "        struct edge_ {",
            "            int from, to;",
            "            ll cap, flow ;",
            "        };",
            "",
            "        int n;",
            "        vector<vector<edge>> G ;",
            "        vector<pair<int,int>> pos;",
            "        vector<int> level, iter;",
            "",
            "        void init_(int n){",
            "            G.resize(n);",
            "            iter.resize(n);",
            "            level.resize(n);",
            "        }",
            "",
            "        void add_edge_(int from , int to , ll cap){",
            "            pos.push_back({from, G[from].size()});",
            "            int from_id = int(G[from].size());",
            "            int to_id = int(G[to].size());",
            "            if (from == to) to_id++;",
            "            G[from].push_back(edge{to, to_id, cap}) ;",
            "            G[to].push_back(edge{from, from_id, 0}) ;",
            "        }",
            "",
            "        int edge_size_(){",
            "            return (int)pos.size();",
            "        }",
            "",
            "        edge_ get_edge_(int k){",
            "            edge e = G[pos[k].first][pos[k].second];",
            "            edge re = G[e.to][e.rev];",
            "            return edge_{pos[k].first, e.to, e.cap + re.cap, re.cap};",
            "        }",
            "",
            "        vector<edge_> get_edges_(){",
            "            int m = (int)pos.size();",
            "            vector<edge_> res;",
            "            for(int i = 0; i < m; i++) res.push_back(get_edge_(i));",
            "            return res;",
            "        }",
            "",
            "        void change_edge_(int k, ll cap, ll flow){",
            "            edge &e = G[pos[k].first][pos[k].second];",
            "            edge &re = G[e.to][e.rev];",
            "            e.cap = cap - flow;",
            "            re.cap = flow;",
            "        }",
            "",
            "        void bfs(int s){",
            "            fill(level.begin(),level.end(),-1) ;",
            "            level[s] = 0 ;",
            "            queue<int> que ;",
            "            que.push(s) ;",
            "            while(!que.empty()){",
            "                int v = que.front() ; que.pop() ;",
            "                for(int i = 0 ; i < G[v].size() ; i++){",
            "                    edge e = G[v][i] ;",
            "                    if(e.cap > 0 && level[e.to] == -1){",
            "                        level[e.to] = level[v] + 1 ;",
            "                        que.push(e.to) ;",
            "                    }",
            "                }",
            "            }",
            "        }",
            "",
            "        inline ll dfs(int v , int t , ll f){",
            "            if(v == t) return f ;",
            "            for(int &i = iter[v] ; i < G[v].size() ; i++){",
            "                edge &e = G[v][i] ;",
            "                if(e.cap > 0 && level[e.to] > level[v]){",
            "                    ll d = dfs(e.to,t,min(f,e.cap)) ;",
            "                    if(d > 0){",
            "                        e.cap -= d ;",
            "                        G[e.to][e.rev].cap += d ;",
            "                        return d ;",
            "                    }",
            "                }",
            "            }",
            "            return 0 ;",
            "        }",
            "",
            "        ll max_flow_(int s , int t, ll flow_limit){",
            "            ll flow = 0 ;",
            "            for(;;){",
            "                bfs(s) ;",
            "                if(level[t] == -1) return flow ;",
            "                fill(iter.begin(),iter.end(),0) ;",
            "                ll f = dfs(s,t,flow_limit-flow);",
            "                while(f > 0){",
            "                    flow += f ;",
            "                    f = dfs(s,t,flow_limit-flow);",
            "                }",
            "            }",
            "        }",
            "",
            "        vector<bool> min_cut_(int s){",
            "            vector<bool> res(n,false);",
            "            queue<int> que;",
            "            que.push(s);",
            "            while(!que.empty()){",
            "                int p = que.front(); que.pop();",
            "                res[p] = true;",
            "                for(edge e : G[p]){",
            "                    if(e.cap > 0 && !res[e.to]){",
            "                        res[e.to] = true;",
            "                        que.push(e.to);",
            "                    }",
            "                }",
            "            }",
            "            return res;",
            "        }",
            "",
            "    public:",
            "        Dinic() {}",
            "        Dinic(int n_): n(n_) { init_(n); }",
            "        void init(int n) { init_(n); }",
            "        int edge_size() { return edge_size_(); }",
            "        void add_edge(int from , int to , ll cap) { add_edge_(from, to, cap); }",
            "        edge_ get_edge(int k) { return get_edge_(k); }",
            "        vector<edge_> get_edges() { return get_edges_(); }",
            "        void change_edge(int k, ll cap, ll flow) { change_edge_(k, cap, flow); }",
            "        ll max_flow(int s , int t, ll flow_limit = inf){ return max_flow_(s,t,flow_limit) ; }",
            "        vector<bool> min_cut(int s) { return min_cut_(s); }",
            "};",
            "",
            "// function                           : return                : description",
            "// --------------------------------------------------------------------------------------------------------",
            "// constructor()                      :                       : ",
            "// constructor(n)                     :                       : サイズ n で初期化する",
            "// init(int n)                        : void                  : サイズ n で初期化する",
            "// add_edge(int from, int to, ll cap) : void                  : 容量が cap の from から to への辺を張る",
            "// edge_size()                        : int                   : 辺のサイズを返す",
            "// get_edge(int k)                    : void                  : k 番目の辺の情報(始点, 行き先, 容量, 流量)を返す",
            "// get_edges()                        : vector<edge_>         : 全ての辺の情報(始点, 行き先, 容量, 流量)を返す",
            "// change_edge(int k)                 : void                  : k 番目の辺を変更する",
            "// max_flow(int s, int t)             : ll                    : s から t への最大流量を返す",
            "// min_cut(int s)                     : vector<bool>          : 最小カットを構成する集合 S を true にして返す",
            "// --------------------------------------------------------------------------------------------------------",
        ],
        "description": ""
    },


    "mincostflow": {
        "prefix": "mincostflow",
        "body": [
            "struct MinCostFlow{",
            "    ",
            "    private:",
            "        static const ll inf = LLONG_MAX;",
            "        struct edge",
            "        {",
            "            int to , rev ;",
            "            ll cost , cap ;",
            "        };",
            "",
            "        struct edge_ {",
            "            int from, to;",
            "            ll cap, flow , cost;",
            "        };",
            "",
            "        int n;",
            "        vector<vector<edge>> G ;",
            "        vector<pair<int,int>> pos;",
            "        vector<ll> dist , h;",
            "        vector<int> prevv , preve ;",
            "",
            "        void init_(int n_){",
            "            G.resize(n_);",
            "            dist.resize(n_);",
            "            h.resize(n_);",
            "            prevv.resize(n_);",
            "            preve.resize(n_);",
            "        }",
            "",
            "        void add_edge_(int from, int to, ll cap, ll cost){",
            "            pos.push_back({from, G[from].size()});",
            "            int from_id = int(G[from].size());",
            "            int to_id = int(G[to].size());",
            "            if (from == to) to_id++;",
            "            G[from].push_back(edge{to, to_id, cost, cap}) ;",
            "            G[to].push_back(edge{from, from_id, -cost, 0}) ;",
            "        }",
            "",
            "        int edge_size_(){",
            "            return (int)pos.size();",
            "        }",
            "",
            "        edge_ get_edge_(int k){",
            "            edge e = G[pos[k].first][pos[k].second];",
            "            edge re = G[e.to][e.rev];",
            "            return edge_{pos[k].first, e.to, e.cap + re.cap, re.cap, e.cost};",
            "        }",
            "",
            "        vector<edge_> get_edges_(){",
            "            int m = (int)pos.size();",
            "            vector<edge_> res;",
            "            for(int i = 0; i < m; i++) res.push_back(get_edge_(i));",
            "            return res;",
            "        }",
            "",
            "        vector<pair<ll,ll>> min_flow_(int s, int t, ll flow_limit){",
            "            vector<pair<ll,ll>> res = {{0,0}};",
            "            ll flow = 0;",
            "            ll cost = 0 ;",
            "            ll prev_cost_per_flow = -1;",
            "            fill(h.begin(), h.end(),0);",
            "            while(flow < flow_limit){",
            "                fill(dist.begin(),dist.end(),9223372036854775807LL) ;",
            "                priority_queue<pair<ll,int>,vector<pair<ll,int>>,greater<pair<ll,int>>> que ;",
            "                dist[s] = 0 ;",
            "                que.push(pair<ll,int>(0,s)) ;",
            "                while(!que.empty()){",
            "                    pair<ll,int> p = que.top() ; que.pop() ;",
            "                    int v = p.second ;",
            "                    if(dist[v] < p.first) continue ;",
            "                    for(int i = 0 ; i < G[v].size() ; i++){",
            "                        edge e = G[v][i] ;",
            "                        if(e.cap > 0 && dist[e.to] > dist[v] + h[v] - h[e.to] + e.cost){",
            "                            dist[e.to] = dist[v] + h[v] - h[e.to] + e.cost ;",
            "                            prevv[e.to] = v ;",
            "                            preve[e.to] = i ;",
            "                            que.push(P(dist[e.to],e.to)) ;",
            "                        }",
            "                    }",
            "                }",
            "                if(dist[t] == inf) break; // 総流量fを流すことができなかった",
            "                for(int i = 0 ; i < n ; i++) h[i] += dist[i] ;",
            "                ll d = flow_limit - flow ;",
            "                for(int v = t ; v != s ; v = prevv[v]) d = min(d,G[prevv[v]][preve[v]].cap) ;",
            "                for(int v = t ; v != s ; v = prevv[v]){",
            "                    edge &e = G[prevv[v]][preve[v]] ;",
            "                    e.cap -= d ;",
            "                    G[e.to][e.rev].cap += d ;",
            "                }",
            "                cost += h[t] * d;",
            "                flow += d;",
            "                if(prev_cost_per_flow == h[t]) res.pop_back();",
            "                res.push_back({flow, cost});",
            "                prev_cost_per_flow = h[t];",
            "            }",
            "            return res ;",
            "        }",
            "    ",
            "    public:",
            "        MinCostFlow() {}",
            "        MinCostFlow(int n_): n(n_) { init_(n); }",
            "        void init(int n) { init_(n); }",
            "        int edge_size() { return edge_size_(); }",
            "        void add_edge(int from , int to , ll cap, ll cost) { add_edge_(from, to, cap, cost); }",
            "        edge_ get_edge(int k) { return get_edge_(k); }",
            "        vector<edge_> get_edges() { return get_edges_(); }",
            "        ll min_cost(int s, int t, ll flow_limit = inf){ return min_flow_(s,t,flow_limit).back().second; }",
            "        pair<ll,ll> min_cost_flow(int s, int t, ll flow_limit = inf){ return min_flow_(s,t,flow_limit).back(); }",
            "        vector<pair<ll,ll>> slope(int s, int t, ll flow_limit = inf){ return min_flow_(s,t,flow_limit); }",
            "};",
            "",
            "// function                           : return                : description",
            "// --------------------------------------------------------------------------------------------------------------------------------------------",
            "// constructor()                               :                       : ",
            "// constructor(n)                              :                       : サイズ n で初期化する",
            "// init(int n)                                 : void                  : サイズ n で初期化する",
            "// add_edge(int from, int to, ll cap, ll cost) : void                  : 容量が cap の from から to への辺を張る",
            "// edge_size()                                 : int                   : 辺のサイズを返す",
            "// get_edge(int k)                             : void                  : k 番目の辺の情報(始点, 行き先, 容量, コスト, 流量)を返す",
            "// get_edges()                                 : vector<edge_>         : 全ての辺の情報(始点, 行き先, 容量, コスト, 流量)を返す",
            "// min_cost(int s, int t)                      : ll                    : s から t へ目一杯流した時の最小コストを返す",
            "// mix_cost(int s, int t, flow_limit)          : ll                    : s から t へ flow_limit まで目一杯流した時の最小コストを返す",
            "// mix_cost_flow(int s, int t)                 : pair<ll,ll>           : s から t へまで目一杯流した時の 流量, 最小コストを返す",
            "// mix_cost_flow(int s, int t, flow_limit)     : pair<ll,ll>           : s から t へ flow_limit まで目一杯流した時の流量, 最小コストを返す",
            "// slope(int s, int t)                         : vector<pair<ll,ll>>   : s から t へまで目一杯流した時の流量, コストの折線グラフを返す",
            "// slope(int s, int t, flow_limit)             : vector<pair<ll,ll>>   : s から t へ flow_limit まで目一杯流した時の流量, コストの折線グラフを返す",
            "// --------------------------------------------------------------------------------------------------------------------------------------------",
        ],
        "description": ""
    },

    "suffix_array": {
        "prefix": "suffix_array",
        "body": [
            "struct SuffixArray{",
            "    private:",
            "        int n_;",
            "        vector<int> S;",
            "        vector<int> suffix_array;",
            "        vector<int> lcp_array;",
            "        vector<vector<int>> lcp_sparse_table;",
            "        vector<int> log_table;",
            "        vector<int> rnk;",
            "        int up;",
            "",
            "        void init_(string T){",
            "            n_ = (int)T.size();",
            "            S.resize(n_);",
            "            up = 255;",
            "            for(int i = 0; i < n_; i++) S[i] = T[i];",
            "        }",
            "        ",
            "        void init_(vector<int> T){",
            "            n_ = int(T.size());",
            "            S.resize(n_);",
            "            std::vector<int> idx(n_);",
            "            iota(idx.begin(), idx.end(), 0);",
            "            sort(idx.begin(), idx.end(), [&](int l, int r) { return T[l] < T[r]; });",
            "            int now = 0;",
            "            for (int i = 0; i < n_; i++) {",
            "                if (i && T[idx[i - 1]] != T[idx[i]]) now++;",
            "                S[idx[i]] = now;",
            "            }",
            "            up = now;",
            "        }",
            "",
            "        void build_(){",
            "            suffix_array = sa_is(S,up);",
            "            lcp_array = get_lcp_(S,suffix_array);",
            "            make_lcp_sparse_table();",
            "        }",
            "        ",
            "        vector<int> substr(int pos, int n){",
            "            if((int)S.size() < n) return {};",
            "            vector<int> ret(n-pos);",
            "            for(int i = 0; i < n - pos; i++) ret[i] = S[i+pos];",
            "            return ret;",
            "        }",
            "",
            "        vector<int> sa_naive(vector<int>& s) {",
            "            int n = int(s.size());",
            "            vector<int> sa(n);",
            "            iota(sa.begin(), sa.end(), 0);",
            "            sort(sa.begin(), sa.end(), [&](int l, int r) {",
            "                if (l == r) return false;",
            "                while (l < n && r < n) {",
            "                    if (s[l] != s[r]) return s[l] < s[r];",
            "                    l++;",
            "                    r++;",
            "                }",
            "                return l == n;",
            "            });",
            "            return sa;",
            "        }",
            "",
            "        vector<int> sa_doubling(vector<int>& s) {",
            "            int n = int(s.size());",
            "            vector<int> sa(n), rnk = s, tmp(n);",
            "            iota(sa.begin(), sa.end(), 0);",
            "            for (int k = 1; k < n; k *= 2) {",
            "                auto cmp = [&](int x, int y) {",
            "                    if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];",
            "                    int rx = x + k < n ? rnk[x + k] : -1;",
            "                    int ry = y + k < n ? rnk[y + k] : -1;",
            "                    return rx < ry;",
            "                };",
            "                sort(sa.begin(), sa.end(), cmp);",
            "                tmp[sa[0]] = 0;",
            "                for (int i = 1; i < n; i++) {",
            "                    tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);",
            "                }",
            "                swap(tmp, rnk);",
            "            }",
            "            return sa;",
            "        }",
            "",
            "        // SA-IS",
            "        vector<int> sa_is(vector<int>& s, int upper){",
            "",
            "            int n = (int)s.size();",
            "",
            "            if(n == 0) return {};",
            "            if(n == 1) return {0};",
            "            if(n == 2) {",
            "                if(s[0] < s[1]) return {0,1};",
            "                else return {1,0};",
            "            }",
            "",
            "            if(n < 10) return sa_naive(s);",
            "            if(n < 40) return sa_doubling(s);",
            "",
            "            vector<int> sa(n);",
            "            vector<bool> ls(n,false); // L := s[i] > s[i+1] , S:= s[i] < s[i+1]",
            "",
            "            // L or S",
            "            for(int i = n - 2; i >= 0; i--){",
            "                if(s[i] == s[i+1]) ls[i] = ls[i+1];",
            "                else ls[i] = (s[i] < s[i+1]);",
            "            }",
            "",
            "            // 各文字のSの個数とLの個数を計算して、対応したindex番号を振る。ソートした時 L -> S の順になる。",
            "            // 具体的には https://mametter.hatenablog.com/entry/20180130/p1 のような表を作る",
            "            vector<int> sum_l(upper+1), sum_s(upper+1);",
            "            for(int i = 0; i < n; i++){",
            "                if(!ls[i]) sum_s[s[i]]++;",
            "                else sum_l[s[i]+1]++;",
            "            }",
            "            for(int i = 0; i <= upper; i++){",
            "                sum_s[i] += sum_l[i];",
            "                if(i < upper) sum_l[i+1] += sum_s[i];",
            "            }",
            "",
            "            auto induce = [&](const vector<int> &lms){",
            "                fill(sa.begin(), sa.end(), -1);",
            "                vector<int> buf(upper+1);",
            "                copy(sum_s.begin(), sum_s.end(), buf.begin());",
            "                for(int d: lms){",
            "                    if(d == n) continue;",
            "                    sa[buf[s[d]]] = d;",
            "                    buf[s[d]]++;",
            "                }",
            "                // 現状のsaを頼りに1文字前がL型の文字を振り分ける(saを前から見ていく)",
            "                copy(sum_l.begin(), sum_l.end(), buf.begin());",
            "                sa[buf[s[n-1]]++] = n - 1; // 一番最後の文字 p = s[n-1] は p を先頭にする文字列の中で最も辞書順が小さい",
            "                for(int i = 0; i < n; i++){",
            "                    int v = sa[i];",
            "                    if(v >= 1 && !ls[v-1]){",
            "                        sa[buf[s[v-1]]] = v - 1;",
            "                        buf[s[v-1]]++;",
            "                    }",
            "                }",
            "                // 現状のsaを頼りに1文字前がS型の文字を振り分ける(saを後ろから見ていく)",
            "                copy(sum_l.begin(), sum_l.end(), buf.begin());",
            "                for(int i = n - 1; i >= 0; i--){",
            "                    int v = sa[i];",
            "                    if(v >= 1 && ls[v-1]){",
            "                        buf[s[v-1]+1]--;",
            "                        sa[buf[s[v-1]+1]] = v - 1;",
            "                    }",
            "                }",
            "            };",
            "",
            "            vector<int> lms_map(n+1,-1);",
            "            int m = 0;",
            "            for(int i = 1; i < n; i++){",
            "                if(!ls[i-1] && ls[i]){",
            "                    lms_map[i] = m++;",
            "                }",
            "            }",
            "",
            "            vector<int> lms;",
            "            lms.reserve(m);",
            "            for(int i = 1; i < n; i++){",
            "                if(!ls[i-1] && ls[i]){",
            "                    lms.push_back(i);",
            "                }",
            "            }",
            "",
            "            induce(lms);",
            "",
            "            if(m){",
            "                vector<int> sorted_lms; // induce_sortをした後、辞書順(仮)になっているlmsが格納される",
            "                for(int v: sa){",
            "                    if(lms_map[v] != -1) sorted_lms.push_back(v);",
            "                }",
            "                vector<int> rec_s(m);",
            "                int rec_upper = 0;",
            "                rec_s[lms_map[sorted_lms[0]]] = 0;",
            "",
            "                // O(n) で各LMSに辞書順を割り振ることができる (induce_sortをしたため)",
            "                for(int i = 1; i < m; i++){",
            "                    int l = sorted_lms[i-1], r = sorted_lms[i];",
            "                    int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;",
            "                    int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;",
            "                    bool same = true;",
            "                    if(end_l - l != end_r - r) same = false;",
            "                    else{",
            "                        while(l < end_l){",
            "                            if(s[l] != s[r]) break;",
            "                            l++;",
            "                            r++;",
            "                        }",
            "                        if(l == n || s[l] != s[r]) same = false;",
            "                    }",
            "                    if(!same) rec_upper++;",
            "                    rec_s[lms_map[sorted_lms[i]]] = rec_upper;",
            "                }",
            "",
            "                // rec_sa[i]: rec_saの辞書順 i 番目は何文字目から始まる接尾辞か",
            "                auto rec_sa = sa_is(rec_s, rec_upper);",
            "                ",
            "                for(int i = 0; i < m; i++) sorted_lms[i] = lms[rec_sa[i]];",
            "",
            "                induce(sorted_lms);",
            "            }",
            "",
            "            return sa;",
            "        }",
            "",
            "        template<typename T> vector<int> get_lcp_(vector<T>& s, vector<int>& sa){",
            "            int n = (int)s.size();",
            "            // i文字目から始まる接尾辞が辞書順で何番目であるか",
            "            rnk.resize(n);",
            "            for(int i = 0 ; i < n; i++){",
            "                rnk[sa[i]] = i;",
            "            }",
            "            vector<int> lcp(n-1);",
            "            int h = 0;",
            "            for(int i = 0; i < n; i++){",
            "                if(h > 0) h--;",
            "                if(rnk[i] == 0) continue;",
            "                int j = sa[rnk[i] - 1];",
            "                for(; j + h < n && i + h < n; h++){",
            "                    if(s[j+h] != s[i+h]) break;",
            "                }",
            "                lcp[rnk[i] - 1] = h;",
            "            }",
            "            return lcp;",
            "        }",
            "",
            "        void make_lcp_sparse_table(){",
            "            const int inf = 1e9;",
            "            int logn = 0, ex = 1;",
            "            int n = n_;",
            "            while(ex < n){",
            "                ex *= 2;",
            "                logn++;",
            "            }",
            "",
            "            lcp_sparse_table.assign(ex,vector<int>(logn,inf));",
            "            for(int i = 0; i < n; i++) lcp_sparse_table[i][0] = lcp_array[i];",
            "            for(int j = 1; j < logn; j++){",
            "                for(int i = 0; i + (1 << j) <= ex ; i++){",
            "                    lcp_sparse_table[i][j] = min(lcp_sparse_table[i][j-1], lcp_sparse_table[i+(1<<(j-1))][j-1]);",
            "                }",
            "            }",
            "",
            "            log_table.assign(n+1,0);",
            "            for(int i = 2; i < n; i++) log_table[i] = log_table[i >> 1] + 1;",
            "        }",
            "",
            "        int lcp_rmq_(int l, int r){",
            "            l = rnk[l];",
            "            r = rnk[r];",
            "            if(l > r) swap(l,r);",
            "            int k = log_table[r-l];",
            "            return min(lcp_sparse_table[l][k],lcp_sparse_table[r-(1<<k)][k]);",
            "        }",
            "",
            "        bool is_include_(vector<int>& t){",
            "            int lef = 0, rig = suffix_array.size();",
            "            while(rig - lef > 1){",
            "                int mid = (lef + rig) / 2;",
            "                int k = suffix_array[mid];",
            "                bool ok = true;",
            "                for(int i = 0; i < (int)t.size(); i++){",
            "                    if(k + i >= (int)S.size() || S[k + i] < t[i]) break;",
            "                    if(S[k + i] > t[i]) {",
            "                        ok = false;",
            "                        break;",
            "                    }",
            "                }",
            "                if(ok) lef = mid;",
            "                else rig = mid;",
            "            }",
            "            int pos = suffix_array[lef];",
            "            return substr(pos,pos+(int)t.size()) == t;",
            "        }",
            "",
            "        bool is_include_(string T){",
            "            vector<int> t((int)T.size());",
            "            for(int i = 0; i < (int)T.size(); i++) t[i] = T[i];",
            "            return is_include_(t);",
            "        }",
            "",
            "    public:",
            "        SuffixArray() { }",
            "        SuffixArray(string T) { init_(T); }",
            "        SuffixArray(vector<int> T) { init_(T); }",
            "        void init(string T) { init_(T); }",
            "        void init(vector<int> T) { init_(T); }",
            "        void build() { build_(); }",
            "        vector<int> get_suffix_array() { return suffix_array; }",
            "        vector<int> get_lcp_array() { return lcp_array; }",
            "        int get_lcp(int l, int r) { return lcp_rmq_(l,r); }",
            "        bool is_include(vector<int> T) { return is_include_(T); }",
            "        bool is_include(string T) { return is_include_(T); }",
            "        int order(int k) { return rnk[k]; }",
            "};",
            "",
            "// function                      : return     : description",
            "// -----------------------------------------------------------------",
            "// constructor()                 :             : コンストラクタを行わない場合に利用",
            "// constructor(vector<int> T)    :             : ",
            "// constructor(string T)         :             : ",
            "// init(vector<int> T)           :             : 初期化",
            "// init(string T)                :             : 初期化",
            "// build()                       : void        : ビルドを行う, suffix_array, lcp_array, lcp_sparse_tableを求める",
            "// get_suffix_array()            : vector<int> : suffix_arrayを返す",
            "// get_lcp_array()               : vector<int> : lcp_arrayを返す",
            "// get_lcp_(int l, inr r)        : int         : l 番目目から始まる文字列と r 番目から始まる文字列のlcpを求める",
            "// is_include(vector<int> T)     : bool        : S が T を含んでいるか",
            "// is_include(string T)          : bool        : S が T を含んでいるか",
            "// order(k)                      : int         : S[i:n] の文字列が辞書順で何番目のsuffixであるか",
            "// ------------------------------------------------------------------",
            "// verify",
            "// https://judge.yosupo.jp/problem/suffixarray (get_suffix_array)",
            "// https://onlinejudge.u-aizu.ac.jp/problems/ALDS1_14_D (is_include)",
            "// https://atcoder.jp/contests/abc150/submissions/35659132 (lcp)",
        ],
        "description": ""
    },

    "fraction": {
        "prefix": "fraction",
        "body": [
            "struct Frac{",
            "    ll a , b;",
            "    Frac(ll a_, ll b_): a(a_), b(b_) {}",
            "",
            "    bool operator< (const Frac& x) const {",
            "        return a * x.b > b * x.a ;",
            "    }",
            "    bool operator> (const Frac& x) const {",
            "        return b * x.a < a * x.b ;",
            "    }",
            "};",
        ],
        "description": ""
    },

    "sorted_list": {
        "prefix": "sorted_list",
        "body": [
            "template<typename T> struct SortedNode{",
            "",
            "    T value;",
            "    T total;",
            "    SortedNode *ROOT;",
            "    SortedNode *lef, *rig, *par;",
            "    SortedNode *next, *prev;",
            "    int sz;",
            "    bool is_virtual;",
            "",
            "    SortedNode(): lef(nullptr), rig(nullptr), par(nullptr), ROOT(this), next(nullptr), prev(nullptr), sz(0), is_virtual(true) {}",
            "    SortedNode(T x): lef(nullptr), rig(nullptr), par(nullptr), next(nullptr), prev(nullptr), sz(1), value(x), is_virtual(false) {}",
            "",
            "    int state(){",
            "        if(!this->par) return 0;",
            "        if(this->par->lef == this) return 1;",
            "        if(this->par->rig == this) return -1;",
            "        return 0;",
            "    }",
            "",
            "    void rotate(){",
            "        SortedNode *pp, *p, *c;",
            "        p = this->par;",
            "        pp = p->par;",
            "",
            "        if(p->lef == this){",
            "            c = this->rig;",
            "            this->rig = p;",
            "            p->lef = c;",
            "        }",
            "        else{",
            "            c = this->lef;",
            "            this->lef = p;",
            "            p->rig = c;",
            "        }",
            "        if(pp && pp->lef == p) pp->lef = this;",
            "        if(pp && pp->rig == p) pp->rig = this;",
            "        this->par = pp;",
            "        p->par = this;",
            "        if(c) c->par = p;",
            "        p->update();",
            "        this->update();",
            "    }",
            "",
            "    void splay(){",
            "        while(this->state() != 0){",
            "            if(this->par->state() == 0){",
            "                this->rotate();",
            "            }",
            "            else if(this->state() == this->par->state()){",
            "                this->par->rotate();",
            "                this->rotate();",
            "            }",
            "            else{",
            "                this->rotate();",
            "                this->rotate();",
            "            }",
            "        }",
            "    }",
            "",
            "    void update(){",
            "        this->sz = 1 ;",
            "        if(this->is_virtual) this->sz = 0;",
            "        else this->total = this->value;",
            "        if(this->lef){",
            "            this->sz += this->lef->sz;",
            "            this->total = this->total + this->lef->total;",
            "        }",
            "        if(this->rig){",
            "            this->sz += this->rig->sz;",
            "            this->total = this->total + this->rig->total;",
            "        }",
            "    }",
            "",
            "    SortedNode *get(int k, SortedNode *root){",
            "        if(root->sz < k) return nullptr;",
            "        SortedNode *now = root;",
            "        while(true){",
            "            int lsz = now->lef ? now->lef->sz : 0;",
            "            if(k < lsz){",
            "                now = now->lef;",
            "            }",
            "            if(k == lsz){",
            "                now->splay();",
            "                return now;",
            "            }",
            "            if(k > lsz){",
            "                now = now->rig;",
            "                k = k - lsz - 1;",
            "            }",
            "        }",
            "    }",
            "",
            "    SortedNode *merge(SortedNode *lef_root, SortedNode *rig_root){",
            "        if(!lef_root) return rig_root;",
            "        if(!rig_root) return lef_root;",
            "        lef_root = get(lef_root->sz-1, lef_root);",
            "        lef_root->rig = rig_root;",
            "        rig_root->par = lef_root;",
            "        lef_root->next = rig_root;",
            "        rig_root->prev = lef_root;",
            "        lef_root->update();",
            "        return lef_root;",
            "    }",
            "",
            "    // [0,lef_cnt), [lef_cnt,size) に分割する",
            "    pair<SortedNode*,SortedNode*> split(int lef_cnt , SortedNode *root){",
            "        if(!root) return {nullptr,nullptr};",
            "        if(lef_cnt == 0) {",
            "            root = get(0,root);",
            "            return {nullptr, root};",
            "        }",
            "        // if(lef_cnt == root->sz) return {root, nullptr};",
            "        SortedNode *lef_root, *rig_root, *mid_root;",
            "        root = get(lef_cnt, root);",
            "        lef_root = root->lef;",
            "        rig_root = root;",
            "        rig_root->lef = nullptr;",
            "        lef_root->par = nullptr;",
            "        rig_root->prev = nullptr;",
            "        lef_root = get(lef_root->sz-1,lef_root);",
            "        lef_root->next = nullptr;",
            "        rig_root->update();",
            "        return {lef_root,rig_root};",
            "    }",
            "",
            "    // [0,first_cnt), [first_cnt,second_cnt), [second_cnt,size) に分割する",
            "    tuple<SortedNode*,SortedNode*,SortedNode*> split3(int first_cnt , int second_cnt , SortedNode *root){",
            "        auto[lef_root,rroot] = split(first_cnt,root);",
            "        auto[mid_root,rig_root] = split(second_cnt-first_cnt,rroot);",
            "        return {lef_root,mid_root,rig_root};",
            "    }",
            "",
            "",
            "    // node: 挿入するノード, root: 挿入が行われる木",
            "    pair<SortedNode*,bool> insert(SortedNode *node, SortedNode *root){",
            "        auto[rt,cnt] = less_count(node->value, root);",
            "        if(rt) root = rt;",
            "        auto[lef_root, rig_root] = split(cnt,root);",
            "        bool first = cnt == 0 ? true : false ;",
            "        return {merge(merge(lef_root,node),rig_root),first};",
            "    }",
            "",
            "    tuple<SortedNode*,SortedNode*,SortedNode*> remove(int k, SortedNode *root){",
            "        root = get(k,root);",
            "        SortedNode *lef_root = root->lef;",
            "        SortedNode *rig_root = root->rig;",
            "        if(lef_root) lef_root->par = nullptr;",
            "        if(rig_root) rig_root->par = nullptr;",
            "        root->lef = nullptr;",
            "        root->rig = nullptr;",
            "        root->prev = nullptr;",
            "        root->next = nullptr;",
            "        root->update();",
            "        SortedNode *nroot = merge(lef_root,rig_root);",
            "        if(nroot->sz == 0) return {nroot,root,nullptr};",
            "        if(k == 0) {",
            "            nroot = nroot->get(0,nroot);",
            "            return {nroot,root,nroot};",
            "        }",
            "        return {nroot, root, nullptr};",
            "    }",
            "",
            "    // [lef,rig) の区間を消去する",
            "    tuple<SortedNode*,SortedNode*,SortedNode*> remove_section(int lef, int rig, SortedNode *root){",
            "        auto[lef_root,mid_root,rig_root] = split3(lef,rig,root);",
            "        root = merge(lef_root,rig_root);",
            "        if(root->sz == 0) return {root, mid_root, nullptr};",
            "        if(lef == 0){",
            "            root = get(0, root);",
            "            return {root, mid_root, root};",
            "        }",
            "        return {root, mid_root, nullptr};",
            "    }",
            "",
            "    SortedNode *find(T x, SortedNode *root){",
            "        SortedNode *res = nullptr;",
            "        SortedNode *now = root;",
            "        while(true){",
            "            if(!now) break;",
            "            if(now->is_virtual) {",
            "                now = now->lef;",
            "            }",
            "            else{",
            "                if(now->value < x){",
            "                    now = now->rig;",
            "                }",
            "                else if(now->value == x){",
            "                    res = now;",
            "                    break;",
            "                }",
            "                else{",
            "                    now = now->lef;",
            "                }",
            "            }",
            "        }",
            "        return res;",
            "    }",
            "",
            "    pair<SortedNode*,int> count(T x, SortedNode *root){",
            "        if(!find(x,root)) return {root, 0};",
            "        root = binary_search(x, root, true);",
            "        if(!root->prev) {",
            "            auto [rt, cnt] = less_count(root->value, root);",
            "            if(rt) root = rt;",
            "            return {root, cnt};",
            "        }",
            "        auto [rt1, lower] = less_count(root->prev->value, root);",
            "        if(rt1) root = rt1;",
            "        auto [rt2, upper] = less_count(x, root);",
            "        if(rt2) root = rt2;",
            "        return {root, upper-lower} ;",
            "    }",
            "",
            "    // 二分探索をする lower = true or false",
            "    SortedNode *binary_search(T x, SortedNode *root, bool lower){",
            "        SortedNode *res = nullptr;",
            "        SortedNode *now = root;",
            "        while(true){",
            "            if(!now) break;",
            "            if(now->is_virtual) {",
            "                res = now;",
            "                now = now->lef;",
            "            }",
            "            else{",
            "                T value = now->value;",
            "                if(lower){",
            "                    if(value < x) {",
            "                        now = now->rig;",
            "                    }",
            "                    else {",
            "                        res = now;",
            "                        now = now->lef;",
            "                    }",
            "                }",
            "                else{",
            "                    if(value <= x) {",
            "                        now = now->rig;",
            "                    }",
            "                    else {",
            "                        res = now;",
            "                        now = now->lef;",
            "                    }",
            "                }",
            "            }",
            "        }",
            "        res->splay();",
            "        return res;",
            "    }",
            "",
            "    // x以下の個数",
            "    pair<SortedNode*,int> less_count(T x, SortedNode *root){",
            "        SortedNode *now = root, *res = nullptr;",
            "        int cnt = 0;",
            "        while(true){",
            "            if(!now) break;",
            "            if(now->is_virtual) {",
            "                res = now;",
            "                now = now->lef;",
            "            }",
            "            else{",
            "                if(now->value <= x){",
            "                    int lsz = now->lef ? now->lef->sz : 0;",
            "                    cnt += lsz + 1;",
            "                    res = now;",
            "                    now = now->rig;",
            "                }",
            "                else{",
            "                    res = now;",
            "                    now = now->lef;",
            "                }",
            "            }",
            "        }",
            "        if(res) res->splay();",
            "        return {res,cnt};",
            "    }",
            "",
            "    // [l,r) の総和",
            "    pair<SortedNode*,T> get_sum(int l, int r, SortedNode *root){",
            "        if(l == r) return {root, 0};",
            "        auto[lef_root, mid_root, rig_root] = split3(l,r,root);",
            "        T res = mid_root->total;",
            "        return {merge(merge(lef_root,mid_root),rig_root), res};",
            "    }",
            "",
            "    size_t size(SortedNode *root){",
            "        if(!root) return 0 ;",
            "        root->sz = 1 ;",
            "        if(root->is_virtual) root->sz = 0;",
            "        if(root->lef) root->sz += root->lef->sz;",
            "        if(root->rig) root->sz += root->rig->sz;",
            "        return root->sz;",
            "    }",
            "",
            "    void next_node(SortedNode*& iter){",
            "        iter = iter->next;",
            "    }",
            "",
            "    void prev_node(SortedNode*& iter){",
            "        iter = iter->prev;",
            "    }",
            "};",
            "",
            "template<typename T> struct SortedList{",
            "    private:",
            "        SortedNode<T> *root, *begin_node, *end_node;",
            "    public:",
            "        SortedList(){",
            "            root = new SortedNode<T>();",
            "            begin_node = new SortedNode<T>();",
            "            end_node = root;",
            "        }",
            "        T value;",
            "        size_t size() { return root->size(root) ; }",
            "        void insert(T x) { auto[rt,begin] = root->insert(new SortedNode(x),root) ; root = rt; if(begin) begin_node = rt; }",
            "        void erase(int k) { auto[rt,DEL,bt] = root->remove(k,root); root = rt; delete DEL; if(bt) begin_node = bt; }",
            "        void erase_section(int l, int r) { auto[rt,DEL,bt] = root->remove_section(l,r,root); root = rt; delete DEL; if(bt) begin_node = bt; }",
            "        T get(int k) { root = root->get(k,root); return root->value; }",
            "        int count(T x) { auto[rt, cnt] = root->count(x, root); root = rt; return cnt; }",
            "        int less_count(T x) { auto[rt,cnt] = root->less_count(x, root); if(rt) root = rt; return cnt; }",
            "        SortedNode<T> *lower_bound(T x) { return root = root->binary_search(x, root, true); }",
            "        SortedNode<T> *upper_bound(T x) { return root = root->binary_search(x, root, false); }",
            "        SortedNode<T> *find(T x) { return root->find(x,root); }",
            "        ll get_sum(int l, int r) { auto[rt, res] = root->get_sum(l,r,root); root = rt; return res; }",
            "        SortedNode<T> *begin() { return begin_node; }",
            "        SortedNode<T> *end() { return end_node; }",
            "};",
        ],
        "description": ""
    },

    "djikstra": {
        "prefix": "djikstra",
        "body": [
            "int n , m ;",
            "",
            "vector<int> G[202020] ;",
            "ll d[202020] ;",
            "",
            "void djikstra(){",
            "    rep(i,n) d[i] = 1e16 ;",
            "    d[0] = 0 ;",
            "    priority_queue<P,vector<P>,greater<P>> que ;",
            "    que.push(P(0,0)) ;",
            "    while(!que.empty()){",
            "        auto[dist, v] = que.top(); que.pop() ;",
            "        if(d[v] < dist) continue;",
            "        for(int i = 0 ; i < G[v].size() ; i++){",
            "            int u = G[v][i] ;",
            "            if(d[u] > d[v] + 1){",
            "                d[u] = d[v] + 1 ;",
            "                que.push(P(d[u],u)) ;",
            "            }",
            "        }",
            "    }",
            "}",
            "",
        ],
        "description": ""
    },

    "segmenttree": {
        "prefix": "segmenttree",
        "body": [
            "template<typename S, S (*op)(S, S), S (*mapping)(S, S), S (*e)()> struct SegmentTree{",
            "    private:",
            "        int n_, n, log;",
            "        vector<S> node;",
            "",
            "        void init_(S ev) { node = {}; node.resize(2*n-1,ev); }",
            "        ",
            "        void build(vector<S> V){",
            "            n = 1;",
            "            log = 0;",
            "            while(n < n_) n *= 2, log++;",
            "            node.resize(2*n-1,e());",
            "            for(int i = 0; i < n_; i++) node[n-1+i] = V[i];",
            "            for(int i = n - 2; i >= 0; i--) node[i] = op(node[2*i+1], node[2*i+2]);",
            "        }",
            "        ",
            "        void apply_(int k, S x){",
            "            k += n - 1;",
            "            node[k] = mapping(node[k],x);",
            "            while(k > 0){",
            "                k = (k - 1) / 2;",
            "                node[k] = op(node[2*k+1], node[2*k+2]);",
            "            }",
            "        }",
            "",
            "        S get_(int k) const { return node[k+n-1]; }",
            "",
            "        S prod_(int l, int r) const {",
            "            S lval = e(), rval = e();",
            "            l += n - 1;",
            "            r += n - 1;",
            "",
            "            while(l < r){",
            "                if(!(l & 1)) lval = op(lval, node[l++]);",
            "                if(!(r & 1)) rval = op(rval, node[--r]);",
            "                l >>= 1;",
            "                r >>= 1;",
            "            }",
            "            return op(lval, rval);",
            "        }",
            "",
            "        S all_prod_() const { return node[0]; }",
            "",
            "        template<bool (*f)(S)> int max_right_(int l) const {",
            "            return max_right_(l, [](S x) { return f(x); });",
            "        }",
            "",
            "        template<typename F> int max_right_(int l, F f) const {",
            "",
            "            l += n;",
            "            S sval = e();",
            "",
            "            do {",
            "                while(l % 2 == 0) l >>= 1;",
            "                if(!f(op(sval, node[l-1]))) {",
            "                    while(l < n){",
            "                        l = 2 * l;",
            "                        if(f(op(sval, node[l-1]))) {",
            "                            sval = op(sval, node[l-1]);",
            "                            l++;",
            "                        }",
            "                    }",
            "                    return l - n;",
            "                }",
            "                sval = op(sval, node[l-1]);",
            "                l++;",
            "            } while ((l & -l) != l);",
            "",
            "            return n_;",
            "        }",
            "",
            "        template<bool (*f)(S)> int min_left_(int r) const {",
            "            return min_left_(r, [](S x) { return f(x); });",
            "        }",
            "",
            "        template<typename F> int min_left_(int r, F f) const {",
            "            r += n;",
            "            S sval = e();",
            "            do {",
            "                r--;",
            "                while(r > 1 && r & 1) r >>= 1;",
            "                if(!f(op(sval, node[r-1]))) {",
            "                    while(r < n) {",
            "                        r = 2*r+1;",
            "                        if(f(op(sval, node[r-1]))) {",
            "                            sval = op(sval,node[r-1]);",
            "                            r--;",
            "                        }",
            "                    }",
            "                    return r + 1 - n;",
            "                }",
            "                sval = op(sval, node[r-1]);",
            "            } while((r & -r) != r);",
            "",
            "            return 0;",
            "        }",
            "",
            "    public:",
            "        SegmentTree(int n): SegmentTree(vector<S>(n, e())) {}",
            "        SegmentTree(const vector<S>& V): n_((int)V.size()) { build(V); }",
            "        void init(S ev) { init_(ev); }",
            "        void apply(int k, S x) { apply_(k, x); }",
            "        S get(int k) const { return get_(k); }",
            "        S prod(int l, int r) const { return prod_(l, r); }",
            "        S all_prod() const { return all_prod_(); }",
            "        template<bool (*f)(S)> int max_right(int l) const { return max_right_<f>(l); }",
            "        template<bool (*f)(S)> int min_left(int  r) const { return min_left_<f>(r); }",
            "",
            "};",
            "",
            "namespace monoid{",
            "    struct S{ ll sum;};",
            "    S e() { return S{0}; }",
            "    S op(S x , S y) { return S{x.sum + y.sum}; }",
            "    S mapping(S x , S y) { return S{x.sum + y.sum}; }",
            "    int target;",
            "    auto f = [](S x) -> bool { return x.sum < target; };",
            "} using namespace monoid;",
            "",
            "// SegmentTree<S, op, mapping, e> segtree(n)",
        ],
        "description": ""
    },


	"Example": {
		"body": [
		],
		"description": "example",
		"prefix": "example"
	},
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
}